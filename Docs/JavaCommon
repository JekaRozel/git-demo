byte a = 1;
byte b = 2;
byte c = (byte)(a+b); (без обязательного приведения типа не выйдет?)
Автоматическое расширение?
  Классы-обертки : названия отличаются только у Integer Character.
int a = 0;
Integer b = Integer.valueOf(a); //boxing
int c = b.intValue();  // unboxing
Они полезны чтобы хранить символы и числа в коллекциях(они не поддерживают примитивные типы); или для выражения факта отсутствия значения (в переменной ссылочного типа хранить null или ссылку на значение).
Они поддерживают неявное преобразование и над ними можно выполнять операции(но они сами извлекают значение, выполняют операцию, обратно заворачиваются).
  
 Конвертация в строку: String str = Long.toString(12345);
 Конвертация из строки: long a = Long.parseLong("12345");
   В числе 2 в степени n в единицу выставлен только (n+1)-й бит. Все остальные — нули. Например, числа 16 и 32 имеют двоичный вид, соответственно, 10000 и 100000. Если с такими числами выполнить побитовое ИЛИ, то в результате должен получиться 0. Например: 32 & 31 == 0 //true
	Ссылочные типы : МАССИВЫ СТРОКИ
  Объявление переменной не создаёт бъект а объявляет ячейку памяти которая может в будущем содержать ссылку на объект.
Объект создаётся оператором new, который выделяет место под объект и вызывает конструктор(метод инициализирующий внутреннее состояние объекта соответствии с переданными параметрами)
??  тип[] a = new тип[] {1, 2, 3,} НО!!! Если переменная объявляется и инициализируется в одной строчке то можно не использовать new тип[]!! тип[] a = {1, 2, 3,} ??
        varargs
  static int a(int[] numbers) {...} a(new int[]{1,2,3}) простое объявление массива с фиксированным числом элементов, отличное от него
varargs - Объявление метода принимаюещго переменное кол-во параметров: static int b(int ... numbers) {...} b(1,2,3) // многоточие влияет только на то как метод можно вызывать, оcтальное всё работает также как в обычном массиве. 
  Сравнение:
== сравнивает ссылки (ссылаются ли две переменные на один и тот же объект.
.equals()- метод сравнивающий объекты по содержимому (для массивов он не работает, тоже сравнивает ссылки). Для попарного сравнения содержимого массивов надо использовать Arrays.equals(mas1, mas2);. Это для одномерных, для многомерных : Arrays.deepEquals(mas1, mas2); 
!!! import java.util.Arrays; Много полезного !!!
  Распечатка(вывод на консоль) массива:
System.out.println(mas); - выдаст ссылку на ячейку памяти [I@123445]
System.out.println(Arrays.toString(mas)); - выдаст массив
System.out.println(Arrays.deepToString(mas)); - выдаст многомерный массив
char[] charArray = {'a', 'b', 'c'} - массив символов
String string = new String(mas); - строка из массива символов
char[] fromMas = string.toCharArray(); - массив символов из строки
Определение: Строка это ссылочный тип хранящий последовательность символов произвольной длинны // в отличии от других ЯП строка не должна заканчиваться нулевым символом он может использоваться внутри. // длинна строки храниться в отдельном поле
  Неизменяемость - фундаментальное свойство строк в Java. Но для строки String s = "asdsdasd" можно:
int length = s.length(); - узнать длинну
char firstChar = s.charAt(0); - получить символ по индексу
boolean endsWithTable = s.endsWith("table"); - содержит ли суффикс, префикс
boolean containsIs = s.contains("Is"); - содержит ли подстроку.
  Изменение строки связано с созданием нового объкта (возвращением новой строки результата)
String substring = s.substring(0, 6); - взятие подстроки
String substring = s.replace("Imm", "M"); - замена
String allCapitals = s.toUpperCase(); - преобразование регистра
 Конкатенация - создание новой строки из символов исходных строк
 StringBuilder - объект очень похожий на String, но допускающий изменение содержимого
  Сравнить конкатенация и StringBuilder:
конкатенация String a = "hello"; String b = "world"; String ab = a + b;
StringBuilder sb = new  StringBuilder; sb.append(hello); sb.append(world); String ab = sb.toString();
 Сравнение строк: только не ==, либо s1.equals(s2), либо без учёта регистра s1.equalsIgnoreCase(s2);
	УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ. УСЛОВНЫЕ ОПЕРАТОРЫ 
в if(только boolean true/false) 
 swich(char, String, Enum, целочисленный(int, byte, short, кроме long))
	ЦИКЛЫ
Оператор break прерывает цикл и передаёт управление на следующую за циклом строку
Оператор continue досрочно заканчиват текущую итерацию и начинает следующую
Если много вложенных циклов, то break/continue действуют только на самое глубокое вложение, для воздействия нa высшие вложения используют метки outer: {{{{{ break outer}}}}} 
операто return - возврат значения из метки
 	Классы
 объявление класса:
public final class main{}
public - модификатор доступа у класса только public или отсутствует(это значит видимость класса в пределах пакета)
подряд может быть объявлено много классов, но public только оди и его имя совподает с именем класса
final - от нето нельзя наследоваться (относительно других элементов значит что значение этого элемента неизмено)
 состояние члена класса хранится в его полях(переменных членах класса). Поля чаще всего private
Поле константа - static final имя ЗАГЛАВНЫМИ_ЧЕРЕЗ_ПОДЧЁРКИВАНИЯ 
 конструктор - специальный метод вызываемый при создании экземпляра класса (через new). Если параметр конструктора имеет такое же имя как и поле класса, то в конструкторе для доступа к полю класса используется this. . Если в классе нет конструкторов, то автоматически создаётся конструктор без параметров. Если надо запретить создание экземпляров класса, то надо создать private конструктор без параметров.
В классе може быть несколько перегруженных версий конструктора с разными параметрами. Из одиного можно вызывать другой. Задать явные значения для параметров по умолчанию нельзя, но благодаря перегрузке конструкторов это реализуется. 
 Метод
 public void/int/String/... name() { return }
метод исполняется в контексте конкретного экземпляра класса, поэтому может обращаться к полям текущего объекта
может иметь модификатор final - не может переопределятся в классах наследниках
может перегружаться, следовательно и задавать явные значения через перегрузку
static - значит можно вызывать без создания объекта, просто по имени класса
Классы можно вкладывать в классы
 Кроме классов есть интерфейсы, перечисления и аннотации(Объявляются через @ и здесь не разбираем).
  Перечисления enum. Это полноценный ссылочный тип. Его можно рассматривать как класс с фиксированным количеством экземпляров(final полей).
 public enum Name { one, two, other;  fields...,  methods...} 
если после перечисления поставить ; то дальше можно объявлять поля и методы, прнимающий параметры конструктор(но тогда параметры надо передовать каждму перечеслению one(), two(), other().
В перечислениях автоматически доступны методы name, ordinal, статический values. 
name - строка имя элемента перечисления  как в исходном коде
ordinal - число, порядковый номер(с ноля)
values - массив возможных значений перечисления 
 Аннотация @Deprecated - класс устарел и не рекомендуется обычно /** указывают чем заменить */
@SuppressWarnings - временно отключает пердупреждения компилятора на подозрительные места в коде 
	Класс Object.
  Inherite Наследование - создавать класс не с нуля а наследуя или расширяя другие существующие классы
class Child extends Parent {}
Наследоваться можно только от одного класса. Наследник получает все поля и классы родителя. Пользоваться ими может как он сам так и другие программы. Иерархия наследования может быть произвольной(любой) глубины. Вызывать можно а.методыРодителя или а.методыНаследников.
 Методы можно переопределять, т.е. в Наследнике заводить методы с тем же именем и параметрами что и в Родителе. Тип должен совпадать с Родителем или Подклассом(наследником?) и модификатор доступа тот же или более открытый. При этих условиях метод Наследник заменит собой метод Родителя. Рекомендуется ставить #Override пред переопределённым методом
 Создание экземпляра класса Наследника всегда включает в себя инициализацию класса Родителя(вызов его конструктора). Если конструктор без параметров, всё работает само. Если же вызывается конструктор с параметрами, то  в Наследнике первым указывается какие параметры надо передать: super(параметры). Есил вызывается уже переопределённый метод, то super.имяПереопределённогоМетода(параметры). Короч слово super можно использовать только в теле класса Наследника. А иначе всегды вызывается переопределённый в Наследнике метод.
 Object - класс родитель всех классов. Соответственно все классы содержат методы класса Object (их больше десятка, самые популярные: toString(), equals(), hashCode()).
 Методы класса Object
public final native Class getClass() - возвращает в рантайме класс данногообъекта
public native int hashCode() - возвращает хеш-код
public boolean equals(Object obj) - сравнивает объекты
protected native Object clone() throws CloneNotPuppotedException - клонирование объекта
public String toString() - возвращает строковое представление объекта
public final native void notify() - просыпается один поток, который ждёт на "мониторе" данного объекта
public final native void notifyAll() - просыпаются все потоки, которые ждут на "мониторе" данного объекта
public final native void wait(long timeout) throws InteruuptedException - поток переходит в режим ожидания в течение указанного времени
public final void wait() throws InterruptedException - приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
public final void wait(long timeout, int nanos) throws InterruptedException -приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода. или пока не истечёт указанный промежуток времени. 
protected void finalize() throws Throwable - вызывается сборщиком мусора, когда тот определил, что ссылок на объект больше нет.

??? хэш код public native int hashCode(); - метод для выяснения хэшкода(по сути нужен только чтобы хранить объекты в хэш таблице)  и хот спот???
	
	Абстрактные классы.
  public abstract class Name{}
 Абстрактный класс - значит нельзя создавать его экземпляры. Но можно создавать экземпляры его классов Наследников(не являющихся абстрактными).
В абстрактном классе может быть всё то же что и в обычном, поля, конструкторы, методы (всё с реализацией, т.к. от него будут наследоваться). Но могут быть и абстрактные методы без реализации(тогда каждый неабстрактный класс наследник должен предоставить реализацию данного метода). 
Не может быть абстрактных методов в неабстрактных классах.
Они решают две задачи: оперделяют набор публичных методов и так же могут содержать неабстрактные поля и методы, какие-то детали реализации.
  Интерфейсы. (служит для объявление контракта объекта по отношению к внешнему миру)
public interface OrderService {
  Orler[] getOrdersByClient(long clientId); }
 Поля могут быть только public static final (константы)  
 Ничего не public быть не может.
 Все методы интерфейса public abstract и эти модификаторы указывать не надо.
 Возможные в интерфейсе исполняющие методы: public static method(), default method().
 Главная фишка! Можно объявлять классы содержащие неограниченное количество интерфейсов. Даже при наличии наследования от класса.
public class B extends A implements C, D, E {}
Примеры интерфейсов:
public interface CharSequence{int length(); char charAt(int i); CharSequence(int start, int end);}//String, StringBuilder
public interface Appendable { Appendable append(CharSequence csq); Appendable append(CharSequence csq, int start, int end); Appendable append(char c);}//StringBuilder  
  Функциональные интерфейсы - интерфейсы с единственным абстрактным методом. Помечаются аннотацией @FunctionalInterface (не обязательн). 
Примеры: 
public interface Runnable { void run();}
public interface Comparator<T> { int compare(T o1, o2);} //o1<02 -; o1==o2 0; 01>02 +.
 Реализацию функциональных интерфейсоы можно заменять лямбда выражениями (но только их). 
//System.currentTimeMillis() возвращает кол-во миллисекунд с 00.00 01.01.1970
//ещё в плсах "получение экземпляра интерфейса при помощи ссылки на метод с подходящей сигнатурой" (Main::method)
	Исключения
  Исключение - это событие, которое случается в процессе работы программы и прерывает стандартрый ход её исполнения, программа переходит в специальный режим поиска обработчика внештатной ситуции, который решит проблему и вернёт программу в штатный режим работы, а если обработчика не нашлось, то JVM звершит работу, но с подробным описанием проблемы. Примеры:
NullPointerException - обращение по нулевой ссылке(null).
ArrayIndexOutOfBoundException - обращение к несуществующему индексу массива.
StringIndexOutOfBoundException - обращение к несуществующему символу в строке.
FileNotFoundException - обращение к несуществующему файлу. Это подкласс:
IOExeption - ошибки ввода/вывода.
После вылета будет распечатано: тип исключения, сообщение с деталями, стектрейс(цепочка вызовов от входа в программу, до метода где произошла ошибка).
 Исключение это объект какого-то класса исключений. 
Все классы исключений наследуются от Throwable(а он от Object). Особенность в том, что они могут быт "брошены": throw new экземплярНовогоИсключения(строка сообщение). только стектрейс покажет где был создан экземплярНовогоИсключения, а не где было вызвано исключение(произошло само "бросание" throw).
 Частые методы класса Throwable:
getMessage() - возвращает текстовую строку с описанием проблемы
printStackTrace() - печатает стектрейс в стандартный поток ошибок
[] getStackTrace() - печатает стектрейс в массив объектов StackTraceElement с именами класса, метода, файла и номер строки.
getCause() - возвращает другое исключение, явившееся причиной данного, либо null.
[] getSuppressed() - создаёт массив исключений.
  Классификация искючений
 -Исключительные ситуации в JVM
  java.lang.Error

 -Исключительные ситуации в пользовательском коде
   -проверяемые (checked)
    java.lang.Exception
   -непроверяемые (unchecked)
    java.lang.RuntimeException

для checked: исключение либо должно обрабатываться в методе, либо в сигнатуре надо указать : public void name() throws IOExeption 
для unchecked таких ограничений нет, "их можно бросать из любой части программы"
 Как можно создавать свои исключения. Как обычный класс, наследующийся от Exeption/RuntimeExeption, содержащий message и cause (если они требуются). Если он unchecked то просто "бросаем", если checked, то его надо указывать в сигнатуре метода и класса/интерфейса в котором он вызывается. При наследовании и реализации интерфейса нельзя декларировать(Объявлять в сигнатуре) переопределённому методу больше исключений чем у базового(Родителя)
  Обработка исключений.
try {блок кода где могут случаться исключения} catch(классИсключения переменнаяКудаСложимИсключенияНаВремяОбработки){код обработчика}
Всё что объявлено в блоке try в блоке catch уже недоступно. Если в блоке try не вылетело исключений, то блок catch не исполняется, а выполняется дальнейший код. Если в блоке try вылетело исключений, то блок catch исполняется, но дальнейший код всёравно выполняется.
Блоков catch может быть несколько(последовательно друг за другом). Тогда они просматриваются в порядке следования и выбирается первый с подходящим типом исключения. Проверка делается с точностью до подкласса(как на instanceof). Выполняется только один catch. C Java 7 можно обрабатывать сразу несколько типов исключений в одном catch, если они не подклассы друг друга, но должны обрабатываться одинаково.
 После catch есть ещё блок finally который выполняется не смотря на try catch (обычно здесь освобождают ресурсы, закрывают файлы, снимают блокировки.   //недостаток - если исключения вылетели и в try и в finally, то первое(ради которого всё делается) мы потеряем. В таком случае либо применяют ещё один try catch в самом finally, либо с Java 7 в try () добавляют как параметры - ресурсы которые будут задействованы и автоматически закрыты(уже без использования finally).
//Оператор instanceof нужен, чтобы проверить, был ли объект, на который ссылается переменная X, создан на основе какого-либо класса Y.
//ресурс - любой объект реализующий интерфейс AutoCloseable (с одним только методом - close)
  Что делать с брошенными и пойманными исключениями. Если на данном этапе программы мы не знаем что с ним делать, то можно пробросить его дальше(тогда и блок try catch не нужен), до того уровня, где будет ясно как его обработать.
//метод проверяющий есть ли что в сроке  или  null. Objects.toString(object) тоже что и String str = object == null ? "null" : object.toString().
    Логирование
  Лог - список приозошедших событий. 
  Класс Логер  
  Набор классов для организации логирования в стандартной библиотеке Java ("Конкуренты" Stdout Stdr). Но тут преимущества(через конфигурационный файл):
-Точечная настройка логирования(вкл/откл на уровне пакетов и классов)
-Настройка уровня детальности логирования
-Настройка места куда логи будут писаться
-Настройка формата ведения логов
import java.util.logging.*;
public class LogDemo{
private static final Logger LOGGER = Logger.getLogger(LogDemo.class.getName()); }
Логи именуют названия пакета + имяКлассаЛогера
первым параметром метод log класса LOGGER принимает уровень логирования Level, говорящий о степени серъёзности данного сообщения с возможными вариантами SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST(для них всех есть одноимённые методы с соответствующими сообщениями).
  Варианты динамической вставки значений х в сообщение:
LOGGER.log(Level.WARNING, "We have a problem! at X" + x);  
LOGGER.log(Level.WARNING, "We have a problem! at X {O}", x);
LOGGER.log(Level.WARNING, "We have a problem! at X ({O}, {1})", new Object[] {x, y});
LOGGER.log(Level.SEVERE, "Unexpected exception", e);
 Обработчик сообщения Handler(абстрактный класс) определяет куда будут записаны сообщения:
-java.util.logging.ConsoleHandler
-java.util.logging.FileHandler
-java.util.logging.SocketHandler
 Обработчик сообщения Formatter (абстрактный класс) определяет формат вывода:
-java.util.logging.SimpleFormatter
-java.util.logging.XMLFormatter
//и Handler и Formatter можно написать свои

	ДОСТУП К ФАЙЛОВОЙ СИСТЕМЕ
java.io.* библиотека отвечающая за ввод/вывод (но есть и в других)
Класс File (java.io.File) отвечает за доступ с файловой системе
 Экземпляры класса File это файлы 
File javaExecutable = new File*("C;\\jdk1.8.0_60\\bin\\java.exe"); 
и директории 
File networkFolder = new File("\\\\server\\share");
// для unix подобных систем File isExecutable = new File(/"usr/bin/ls");
Сборка пути путём конкатенации строк должна содержать разделители в виде File.separator/File.separatorChar (разделитель путей File.pathSeparator/File.pathSeparatorChar это ;/:)
//String a = "src"; String b = "Main.java; String ab = a + File.separator + b;
Либо пусть сам соберёт: File ab = new File(a, b);
  Экземпляр класса File можно создать указав абсолютынй путь ("/usr/bin/java") или относительный ("java").
Проверка на относительный ли путь a.isAbsolute() //true/false
Извлечение абсолютного пути:
a.getAbsolutePath()/getAbsoluteFile() //String/File
String методы для объекта класса File 
a.getPath(); абсолютный путь
a.getName(); имя файла (выдаёт только с расширением)
a.getParent(); весь путь до файла(кроме файла)
a.getParentFile(); весь путь до файла в другой файл.
a.getCanonicalPath()/a.getCanonicalFile; выдаёт истинный путь к файлу. Этот метод уже может выбрасывать IOExeption (надо отлавливать), т.к. при обращении к диску может произойти ошибка ввода/вывода. //пердыдущие метды обращения к диску не требовали
// следующий методы возвращают и true/false
a.exists(); существует ли на диске
 a.isFile(); является ли файлом
методы для файла
a.length(); размер. есил файла нет вернёт 0
a.lastModified(); время последнего изменения с 1970.есил файла нет вернёт 0.
 a.isDirectory(); является и дирикторией
методы для директории
a.list(); выдаст массив строк с её содержимым, если её не существует то null
a.listFiles();  выдаст массив экземпляроа File с её содержимым, если её не существует то null
   Создание нового пустого файла (балавство):
try{ boolean success = file.createNewFile(); } catch (IOExeption e)  { обработка ошибки } //true если всё прошло успешно и false если файл уже существовал.
boolean b = a.mkdir(); Создание директории одного уровня
boolean b = a.mkdir(); создание вложенных директорий
boolean b = a.delete(); удаляет файлы или пусыте директории 
boolean b = a.renameTo(объект типа File);
// нет метода копирования 
   Начиная с Java 7 появился улучшеный класс File:
java.nio.file.Path 
Path path = Paths.get(prj/java");
File FromPath = path.toFile();
Path fromFile = fromPath.toPath();
Объект Path не привязан к файлу на диске, так сказать "строчка обёрнутая набором методов для синтаксических манипуляций"
У класса Path есть все методы что и у File плюс ещё:
a.getNameCount();
a.getName(1); получение компонента пути по его индексу
a.resolveSibling("javap");
a.startsWith("/usr"); является ли один путь префиксом другого
Path.get("/usr").relativize(java); вычисление относительного пути между двумя местами файловой системы
У Path нет доступа к файловой системе, поэтому когда надо залезть на диск, то используются статические методы класса Files
Files.exists(a);
Files.isRegularFile(a);
Files.size(java);
Files.getLastModifiedTime(a).toMillis();
 И копирование
Files.copy(a, Paths.get("/usr/bin/a_copy"), StandardCopyOption.REPLACE_EXISTING); // move тоже есть
 Для директорий - получение содержимого директории:
try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(a)) { 
for {Path child : dirStream) { System.out.println(child); }} // используется try с ресурсами потому, что DirectoryStream<Path> это директория открытая на чтение (ресурс операционной системы, который нужно освобождать)
 Создание директорий
Files.createDirectory(dir);
Files.createDirectories(dir); 
// опять нет метода удаления директории со всем содержимым
	ПОТОКИ БАЙТ
 Ввод данных:
java.io.InputStream - поток байтов из которого можно читать по одному байту или блоками
 Вывод данных:
java.io.OutputStream - поток байтов в который можно писать. 
Оба класса абстрактые. Основные популярные методы InputStream (все throws IOExeption):
read() возвращает следующий байт из входного потока и сдвигается дальше (считывает один байт, но имеет тип int для того чтобы иметь возможность обозначить конец потока). Когда конец достигнут возвращает -1. Если вернулось что-то другое, то фактически считанный байт можно получить явным приведением int к (byte)(фактически взяв младшие 8 бит int)
 Для больших объёмов данных методы читают блоки байтов и записывают их в переданный массив:
read(byte b[]){return read(b, 0, b.length); - принимает только массив байтов и пытается считать из потока кол-во байт равное длинне массива
read(byte b[], int off, int len) - принимает массив байтов, индекс элемента массива начиная с которого этот массив надо начинать заполнять, кол-во байт которое надо считать из входного потока и записать в массив ( возвращает int - количество фактически считанных бай, может быть меньше чем мы просили int len если поток закончился)
skip(long n) пропускает заданное кол-во байт никуда их не сохраняя (возвращает long фактическое кол-во байт которые удалось пропустить, может отличаться от запрошенных long n)
close() закрывает поток и освобождает связанные с ним ресурсы.  
 Основные популярные методы OutputStream (все throws IOExeption):
аналогичные методы для записи байтов по одному или блоками
write(int b) выводит в поток один байт, младшие 8 бит от int b
Для большого объема данных лучше использовать перегруженные:
write(byte b[]){write(b, 0, b.length); берёт всё содержимое массива
write(byte b[], int off, int len); берёт указанное int len кол-во байт начиная с указанного int off индекса в массиве 
flush() сбрасывает возможные промежуточные буфера где могут накапливаться данные перед передачей системе.
close() закрывает поток и освобождает связанные с ним ресурсы, сбрасывает буфера.
 Стримы рекомендуется использовать в блоке try (с ресурсами) чтобы close был гарантированно вызван.
 Чтение Файлов с диска:
InputStream inputSteram = new FileInputStream(new File("in.txt")); принимает либо строку путь либо java.io.File
InputStream inputStream = Files.newInputSteam(Paths.get("in.txt")); для  java.nio.file.Path
 Запись в файл на диск:
OutputStream outputStream = new FileOutputStream(new File("out.txt"));  принимает либо строку путь либо java.io.File
OutputSteam outputStream = Files.newOutputStream(Paths.get("out.txt")); для java.nio.file.Path 
  Чтобы получать поток из сети надо открыть сетевое соединение:
tyr(Socket socket = new Socket("ya.ru", 80) {
 OutputStream outputStream = socket.getOutputSteam();
 outputStream.write("GET / HTTP/1.0\r\n\r\n".getBytes());
 outputStream.flush();

 InputStream inputStream = socket.getIputStream();
 int read = iputStream.read();
 while (rad >= 0) {
  System.out.print((char) read);
  read = inputStream.read();
}}
 
 Работа с донными уже записаными в память виртуальной машины  
 byte[] dаta = {1, 2, 3, 4, 5};
 InputStream inputStream = new ByteArrayInputStream(data);
 ByteArrayOutputStream();
 Byte[] result = outputStream.toByteArray();

Полезный класс DataOutputStream оборачивает OutputStream и даёт возможность работать уже не с байтами а примитивнымиТипами/строками writeInt(int a)/writeUTF 
Так же и DataInputStream оборачивает InputStream и позволяет работать с примитивнымиТипами/строками readInt()

DeflaterOutputStream(os) - реализует сжатие записываемых данных по алгоритму дефлэйтер
InflaterOutputStream - распаковывает
// закрытие одного стрима вызывает закрытие всех. Достаточно одного close().

	Работа с текстом в потоках ввода/вывода
  Ввод данных
java.io.Reader
методы: 
read(); возвращает int но смотреть надо на 2(а не 1 как с с потоком байт) младших байта.
read(char cbuf[]){return(cbuf, 0, cbuf.length); принимают массивы символов, остальное как с байтами
read(char cbuf[], int off, ijnt len); принимают массивы символов, остальное как с байтами
skip(long n);
  Вывод данных
java.io.Writer аналогичен outputStream только с заменой байтов на char
методы:
write(int c);
write(char cbuf[]){write(cbuf, 0, cbuj.length)};
write(char cbuf[], int off, int len);
  Можно превратить произвольный поток байтов в поток символов, завернув его в InputStreamReader или в OutputStreamWriter. 
Read reader = new InputStreamReader(inputStream, "UTF-8");
Cahrset charset = StandsrdCharsets.UTF_8;
Write writer = new OutputStreamWriter(outputStream, charset);
Обязательно указывать кодировку. Либо как строку "UTF-8", либо ка объект типа charset.
 java.nio.charset; Charset можно получить либо так: Charset.forName("...");(можно получить болише кодировок, но нет гарантий переносимости кода) либо Cahrset charset = StandsrdCharsets.UTF_8;(но кодировки только: UTF-8, UTF-16, ASCI). Если кодировку в конструктор не передавать, то будет использована системная кодировка по-умолчанию, на неё лучше не полагаться. Узнать её можно Charset.defaultCharset().
  Для чтения и записи текстовых файлов есть классы 
FileReader и FileWriter.
Reader neader = new FileReader("in.txt");
Writer writer = new FileWriter("out.txt");
Но в них нельзя указать кодировку, поэтому при работе с файлами кодирвока которых нам известна используют вот такие конструкции:
Reader reader2 = new InputStreamReader( new Jile InputStream("in.txt"), StandardCharses.UTF_8);
Writer writer2 = new OutputStreamWriter( new FileOutputStream("out.txt"). StandardCharsets.UTF_8); 
Классы:
Reader reader = new CharArrayReader( new char[] {'a', 'b', 'c'}); чтение символов из массива
Reader reader2 = new StringReader("Hello World!"); чтение строки из памяти.
 CharArrayWriter write = new CharArrayWriter(); //удобно использовать для тестирования кода
wirter.write("Test");
char[] resultArray = writer.toCharArray();
 StringWriter writer2 = new StringWriter(); // удобно использовать для тестирования кода
writer2.writer("Test");
Stirng resultString = writer2.toString();
   Класс BufferedReader c методами 
BufferedReader(Reader in) который оборачивает произвольный Reader и добавляет к нему буферизацию, даже если  обрабатывает по доному символу, всёравно запрашивает большой объём данных и хранит их в буфере,
String readLine() - читает из потока целую строку до ближайшего символа конца строки(сам символ разделяющий строки не возвращается). Если дочитали до конца строки и поток закончился, то возвращается null.
  Чтобы построчно прочитать и обработать файл:
try (BufferedReader reader = Files.newBufferedReader(Paths.get("in.txt"), standardCharsets.UTF_8)) { string line; while ((line = reader.readLine()) != null){}};
 Для небольшого файла можно проще(вернуть сразу все строки в виде списка:
List<String> lines = Files.readAllLines(Paths.get("in.txt"), StandardCharsets.UTF_8); for (String line : lines) {};
 Аналогично с чтением приоисходит запись:
try (BufferedWriter writer = Files.newBufferedWriter( Path.get("out.txt"), StandardCharsets.UTF_8)){ writer.write("hello");; writer.newLine();} копит в буфер большие куски данных и сбрасывает их в оборачиваемый райтер. newLine - разделитель строк.
Для небольшого файла метод принимает список строк и преврацает его в текстовый файл:
List<String> lines = Arrays.asList("Hello", "world");
Files,write(Paths.get("out.txt"), lines, StandardCharsets.UTF_8);  
       Форматированный ввод/вывод значений разных типов (конвертация) реализован как ндстройка над ридерам и райтером.
  Вывод //объекты преобразуются в строки при помощи метода toString().
package java.io;
pbulic class PrintWriter extends Writer {
 public PrintWriter(Writer out){} //все полученные данные конвертирутся в строки и передаются классу Writer для вывода
 public void print(int i){}
 public void printLn(Object obj){} // принимает любой объект
 public PrintWriter pringf(String format, Object ... args){} принимает строку шаблон format  и набор параметров которые будут подставляться в эту строку args. (места подстановки обозначаются специальными символами %s-место строки %d-целого числа %.3f-вещественного числа округлённого до 3 цифр после запятой. 
Эти методы не бросают IOExeption, а устанавливают внутренний флаг ошибки, чтобы его проверить:
 public boolean checkError(){}
Класс PrintStream пердоставляет те же методы что и PrintWriter, только оборачивает не Writer а OutputStream.(и сам им является). Внутри методов print он сначала преобразует из примитивных методов в строку, а потом сразу в байты, которые передаются нижележащему OutputStream для вывода (гибрид OutputStream и PrintWriter)
java.io.streamTokenizer
StreamNokenize a = newStreamTokenizer(new StringReade("Hi")); умеет рабзирать поток на слова и числа
java.util.StringTokenizer
StringTokenizer b = new StringTokenizer("hi"); читает из строки 
Эти два класса устарели, вот их современный потомок Scanner scr = new Scanner(reader/другие)
.useDelimiter("\\|"); устанавливаем свой разделитель для нарезания входного потока на токены(по-умолчанию пробел)
.useLocale(Locale.forLanguageTag("ru")); региональные настройки, особенности языка
В нём можно парсить
String token = scr.next();
boolean bool = scr.nextBoolean();
double dbl = scr.nextDouble();
int integer = scr.nextInt();

Для общего сведения:
Класс ProcessBuilder отвечает за запуск внешних процессов
ProcessBuilder a = new ProcessBuilder();
a.command("ls", "-l"); указываем запускаемую команду
a.derectiry(new File("/home/jk/"); указываем рабочую директорию, в которой будет запускаться новый процесс
a.redirectInput(Redirect.from(new File("/dev/null"))); подключение потока ввода в процесс. Перенаправить поток в файл или из файла.
a.redirectOutput(Redirect.PIPE); направление потока вывода PIPE - полное получение стрима и прямая работа с ним из java
a.redirectError(Redirect.INHERIT); направление потока ошибок INHERIT- унаследовать поток java процесса(забрать данные из stdr процесса в stdr java) 
Process b = a.stаrt(); стартуем новый процесс. Далее работа с PIPE
try (BufferedReader c = new BufferedReader(new InputStreamReader(b.getInputStream()))){c.lines().forEach(System.out::println);} принимаем всё что выводит поток внешнего процесса и записываем в поток стандартного вывода java процесса(ручная реализация INHERIT)
int exitValue = b.waitFor(); ожидание окончания дочернего процесса и получение его кода возврата.(0 - успех)
if(exitValue != 0) {
System.out.print("aborted");}}}  
   Методы read/write InputStream/OutputStream - блокирующие, программа останавливается пока не получит данные(хотябы 1 байт)/пока всё не запишет. НЕ блокирующие аналоги более низкоуровневые java.nio.channels.*; java.nio.ByteBuffer; "можно из одного треда работать сразу со многими каналами (при калссическом io, на каждый канал нужен свой тред)
   Сериализация - взять из памяти объект, превратить его в набор байтов(вместе со всеми значениями его полей), сделать с ним что угодно(например записать в файл, передать по сети, там декодировать и получить такой же точно объект. 
Класс должен implements Serializable Это маркерный интерфейс(т.е. в неём не объявлено ни одного метода). Поля помеченые transient не будут сериализовываться. Для десериализации предназначен класс ObjectInputStream и его метод readObject()	

		GENERICS
Параметризованные типы. <T>
Значением параметра не может быть примитивный тип или примитивное значение, только ссылочные типы.
public static <T extends Comparable<T>> T minElement(T[] values) {... T min = values[0]; ...} // вместо T будет подставлен любой тип удовлетворяющий условиям extends Comparable<T>
 Класс из стандартной библиотеки java.util;(мини контейнер для одного объекта любого типа) :
puublic final Class Optional<T> {}
он нужен для того, что бы не делать постоянно проверку на null(можно @Nullable, @NonNull, но из сторонних библиотек, не годных для компилятора и его проверок). Как решение:
String text = "bar"; - обычная ссылка
Optional<String> oprionalText = Optional.of("baz:); -потенциально отсутствующая ссылка
вот это:
baz.ifPresent(System.out::println); значит это:
if(s!=null){System.out.println(s);}; // s - обычная переменная String
а это:
String value = bar.orElse("bar"); значит это:
s!=null?s:"bar";
 при наследовании extends используется и для классов и для интерфейсов, перечисляются через амперсанд.
public final class Optional<T extends One & Two & Three>
теперь Т можно использовать в любом месте где и обычное имя типа. Т заданный на уровне класса используется для параметризации эеземпляров, поэтому недоступен в статических полях и методах.
Для статических Т указывается после модификаторов и перед именем возвращаемого типа и не является тем же Т что и указанный после имени возвращаемого типа:
public static <T> Opional <T> of(T value){}
 С классом Optional можно (у этого метода конструктор приватный, экземпляры должны создаваться через статические фабричные методы):
Optional<String> foo = Optional.empty(); возвращае пустой Optional не содержащий ссылку на объект, подгоняет возвращаемое значение к нужному типу.
Optional<String> bar = Optional.of("bar"); возвращает Optional(в данном случае String) содержащий указанный объект(аргумент не может быть null.
Optional<String> baz = Optional.ofNullable("baz"); возвращает Optional(в данном случае String) содержащий указанный объект, если там null, то пустой Optional(в данном случае String).
 Чтобы из Optional параметризованным String получить Optional параметризованный CharSequence надо это явно указать .<явное приведение типов>   
Optional<CharSequence> optionalCharSequence = Optional.<CharSequence>ofNullable("baz");
Optional<String> newOptional = new Optional<>("foobar"); <> дайманд оператор, при использовании new компилятор сам поймёт что подставлять. 
 При использовании параметризованных типов компилятор не создаёт методы для каждого инстанцированного параметра. Будет один класс в котором вместо <T> будет Object.
И уже в процессе испольнения программы компилятор колдует в местах использования различных параметризаций этого класса(например производит неявное приведение типов). Если не использовать(указывать) <T> то тогда везде будет использоваться Object.
 Ограничения: внутри параметризованного класса или метода нельзя создавать экземпляр Т или массив Т; не работает проверка instanceof; приведение типа T a = (T) b выполниться, но не произведёт проверок на правильнось выполнения.
 Для использования Наследников или Родителей класса T надо использовать запись <? super T> для использования Т и его родителей и <? extends T> для использования Т и его наследников. // правило если получать объекты, то ?extends, если передавать, то ?super.
<?> принимает любое значение, через .get возвращает Object. а вызвать метод принимающий это значение вообще не выйдет, компилятор не видит тип.

		Коллекции.

 Недостатки массива: фиксированный размер; нет защиты от изменеий(если доступуен для чтения, то и для записи)
Коллекции легко изменяемы по размеру(просто втавлять и удалять элементы); могут разрешать чтение, но не изменение; много удобных методов.
Коллекции - genericи и параметризуются типом хранимых внутри элементов, следовательно коллекции работают только со ссылочными типами. Чтобы хранить примитивные типы : можно использовать классы обёрткию; можно вручную написать класс похожий на коллекцию, но хранящий примитивы; можно использовать класс из сторонней библиотеки.(два последних напряг).
java.util; тут коллекции
java.util.concurrent; тут коллекции для многопоточных программ.
 Основные классы-коллекции. (Абстрактная) 
public iterface Collertion<E> extends Iterable<E> { //Самый основной
int size(); текущий размер коллекции
boolean isEmpty(); проверка пустоты
boolean contains(Object o); пороверка принадлежности объекта к коллекции
boolean add(E e); добавление элемента в коллекцию
boolean remove(Object o); удаление элемента из коллекции
void clear(); удаление всех элементов из коллекции
}
contains, add, remove используют equals
У коллекций есть метод iterator() унаследованный от java.util.Iterable и возвращающий экземпляр Iterator<Integer>. Он позволяе единообразно обходить элементы любой коллекции. У него есть три метода
.hasNext() проверна наличия следующего элемента
.next() получение найденного следующего элемента
.remove() удаление текущего элемента из коллекциию(текущий это последний возвращённый из next())
  Варианты обхода:
Collection<Integer> collection = ...;

Iterator<Integetr> it = collection.iterator();
while(it.hasNext()) {
Integer element = it.next();
System.out.println(element);}

for(Integer element : collection){
System.out.println(element);}

collection.forEach(System.out::println);(в качестве параметра принимается экземпляр java.util.function.consumer<T> c единственным методом accept(T). используем возможность инстанцировать функциональный интерфейс при помощи ссылки на метод
 
Сокращённые записи не позволяют удалять элементы во время обхода.

Классы нследники:
public iterface List<E> extends Collection<E> {
E get(int index); получение элемента по индексу
E set(int index, E element); замена элемента по индексу
void add(int index, E element); добавление элемента по индексу. (с index сдвигаются вправо на 1 позицию, впуская новый элемент)(add унаследованый от коллекции возвращает элемент в конец списка.
E remove(int index); удаляет элемент по индексу(и возвращает его)
int indexOf(Object o); ищет элемент в списке и возвраащет его индекс первый сначала (не нашёл -1)
int lastIndex0f(Object o); ищет элемент в списке и возвраащет его индекс первый с конца (не нашёл -1)
List<E> subList(int fromIndex, int toIndex); возвращает часть списка в виде отдельного экземпляра List(не копирование, изменение в одном списке будут видны в другом)
  Распросранеённые реализации List:
List<String> list1 = new ArrayList<>();
List поверх массива, даёт максимально дешёвый доступ к элементу по индексу.
List<Integer> list2 = new LinkedList<>();
Основанно на двусвязном списке. Позволяет эффективно добовлять или удалять элементы в начале или в конце списка.

   Вторая разновидность коллекций:
Очередь(первый вошёл, первый вышел) //Queue (FIFO)
public iterface Queue<E> extends Collection<E>{
boolean add(E e); добавляет элемент, если очередь достигла предела то thorows exeption
boolean offer(E e); добавляет элемент, если очередь достигла предела то возвращает false
E remove(); извлекает первый элемент, если очередь пуста то throws...
E poll(); извлекает первый элемент, если очередь пуста то null
E element(); позволяет посмотреть элемент не удаляя его(throws...)
E peek(); позволяет посмотреть элемент не удаляя его(null)
}
Элементы добавляются с хвоста  и извлекаются из головы
 Наследник позволяющий добавлять и удалять элементы как с хвоста так и с головы:
public interface Deque<E> extends Queue<E>{
void addFirst(E e); 
void addLast(E e);
boolean offerFirst(E e);
boolean offerLast(E e);
E removeFirst();
E removeLast();
}
 Реализации Deque:
Deque<Object> d1 = new ArrayDeque<>();
Deque<Integer> d2 = new LinkedList<>(); 

  Третья разновидность множесто (уникальных) не может содержать два элемента равные друг другу
public iterface Set<E> extends Collection<E>{} //методы как и в Collection
.add(дубликат) вернёт false
Реализации интерфейса Set:
Релизация множества на основе Хэш таблицы(использует hashCode() для определения куда положить объект, equals()для сравнения с уже лежащими в таблице элементами)(a.equals(b) ти и a.hashCode()==b.hashCode();
Set<ComplexNumber> numbers = new HashSet<>(); 
numbers.add(new ComplexNumber(3, 3));
nubmers.remove(new <ComplexNumber(3, 3));
Элемент недолжен меняться пока лежит в таблице.
LinkedHashSet<>(); отличается от HashSet(); тем, что запоминает последоватьельность добавления элементов.

  Упорядоченное множество(поэтому итератор проходит в порядке возрастания элементов)
public iterface SortedSet<E> extends Set<E> {
SortedSet<E> subSet( E fromElement, E to Element);
SortedSet<E> headSet(E toElement); возвращает подмножество элементов, меньше чем переданный параметр.(не копия)
SortedSet<E> tailSet(E fromElement);
E first();
E last();
}
Реализация:
SortedSet<String> words = new TreeSet<>();
 
	Четвёртое множество мапа(отображение или ассоциативный массив) представленный интерфейсом java.util.Map;(Не относится к Collection но схож по идеологии)
Элементны индексируются произвольными объектами(а не цифрами как в массиве)
public interface Map<K, V> {
int size(); размер(количество пар ключ-значение хранящихся в данный момент)
boolean isEmpty(); проверка пустоты
boolean containsKey(Object key); проверяет есть ли в мапе сейчас такой ключ
boolean containsValue(Object value); проверяет есть ли сейчас такое значение
V get(Object key); получает значение по ключу
V put (K key, V Value); сохраняет значение по ключу // возвращает значение которое было по задонному ключу в начале запрошенной операции
V remove(Object key); удаляет пару ключ-значение с заданным ключом // возвращает значение которое было по задонному ключу в начале запрошенной операции
void clear(); полностью очищает мапу
Обход всего содержимого:
Если нужны только ключи:
Set<K> keySet(); вернёт множество ключей(дубликаты ключей в мапе недопускаются)
Если нужны только значения:
Collection<V> values(); вернёт коллекцию значений(т.к. про уникальность значений ничего не известно)
Если нужны и ключи и значения:
Set<Map.Entry<K, V>> entrySet(); вернёт множество объектов Entry<K, V> содержащих ключ-значение.
 Примеры использования этих методов:
Map<A, B> map = new HashMap<>();
for (A key : map.keySet()){} обход ключей
for (B value : map.valies()) {} обход значений
for (Map.Entry<A, B> entry : map.entrySet()){
  System.out.printf("%s => %s\n", entry.getKey(), entry.getValue()); } обход пар ключ-значение
map.forEach((k, v) -> System.out.printf("%s => %s\n, k, v)); принимает экземпляр java.util.function.BiConsumer<T, U>:(это функциональный интерфейс с методом) accept(T, U) (с двумя параметрами которым мы передаём лямбда выражение)
 Реализация интерфейса мап:
Map<String, String> map1 = new HashMap<>()/LinkedHashMap<>();
map1.put("foo", "baz");
map1.put("bar", "baz");
map1.remove("bar");
SortedMap<String, String> map2 = new TreeMap<>();
map2.put("foo", "bar");
map2.put("bar", "baz");
map2.subMap("bar", "foo").clear();
 Устаревшие классы java.util.Vector/Stack/Dictionary/Hashtable оставленные лишь для обратной совместимости
  В работе с коллекциями помогает утилитный класс java.util.Collections; в котором есть методы
Collections.shuffle(list); перемешивание
Collections.sort(list); сортировка
Set<String> set = Collections.unmodifiableSet(originalSet);//unmodifiableList(), unmodifiableMap(); эти методы возвращают объект-обёртку, реализующую тот же интерфейс, что и переданный параметр и предоставляющий доступ на чтение к элементам исходной коллекции.
Но попытка изменить содержимое коллекции через этот объект-обёртку set.remove("abc"); выбросит исключение UnsupportedOperationException.
Для конвертации коллекций в массив:
List<Integer> list = ...;
Object[] ar1 = list.toArray(); возвращает содержимое коллекции в виде маасива Objecto[] (т.к. дженерики не позволяют создать массив <Integer>)
Integer[] ar2 = list.toArray(new Integer[list.size()]); а здесь всёже получаем массв Integer[].
 Обратная конвертация из массива в коллекцию:
String[] array = {"A", "B", "C"};
Set<String> set1 = new HashSet<>(Arrays.asList(array)); превращаем массив в список ипередаём его конструктору класса-коллекции
 Set<String> set2 = new HashSet<>(); создаём пустую коллекцию и прередаём в неё все элементы из массива при помощи утилитного метода Collections.addAll(set2, array);
//Коллекции могут содержать только объекты, а массивы могут содержать и примитивы.

Коллекции можно сравнивать по содержимому обычным методом equals(), а для сравнения массивов используется внешний утилитный метод Arrays.equals().

Массивы встроены в язык, а коллекции — обычные классы стандартной библиотеки.

Коллекции могут динамически менять размер, а размер массива фиксируется при создании. //

	Функциональный интерфейс (с java8) 
Интерфейс в котором только один метод(default и static методы, static поля не в счёт, их может быть сколько угодно) компактный кусок кода в качестве параметра в другой код
испоьлзовать компактные лямбда выражения и ссылки на методы. что позволяет писать программы в функциональном стиле (последовательное применение функций к некоторым значениям и другим функциям)(а не сложная структура из циклов, условных операторов и перекладывания значений переменных)
@FunctionalEnterface
public interface FileFilter
java.util.function содержит более сорока стандартных интерфейсов. Они делятся на 5 семейств:
1 Consumer<T> {void accept(T t);} "Потребители" принимают значения но ничего не возвращают взамен. Для примитивов есть IntConsumer, LongConsumer, DoubleConsumer.(опять же потому что дженерики не могут параметризаваться примитивными типами).
Так же есть Consumerы принимающие по два параметра. Один из них BiConsumer<T, U> с методом void accept(T, U) принимающим два параметра и ничего не возвращающем.
2 Supplier<T> {T get();} "Поставщики" они ничего не принимают в качестве параметра, только возвращают каое-то значение. Так же есть BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier.
3 Predicate<T> {boolean test(T t);} "Предикаты" принимает значение какого-либо типа и возвращает boolean true/false. Есть так же IntPredicate, LongPredicate, DoublePredicate и принимающий сразу два параметра "бинарный предикат" BiPredicate<T, U>  
4 Function<T, R> {R apply(T t);} "Функции" принимают аргумент и возвращают значения какого-то типа. Есть функции принимающие два параметра BiFunction. Так же есть масса специализаций функций принимающих на место одного или обоих параметров примитивы. Например DoubleFunction принимающая dobule и возвращающая объект Т, или LongToIntFunction принимает long и возвращает int. ToIntFunction принимает объект Т и возвращающая int. И много других.
5 UnaryOperator<T> extends Function<T, T>{} "Операторы" (частный случай функции) когда на входе и на выходе значения одного и того же типа. BinaryOperator принимает два параметра. Так же Unary/BinaryOperator заведены для Int, Long, Double. 
   Функциональные интерфейсы можно инстанцировать тремя способами:
Можно завести именнованый или анонимный класс реализующий интерфейс.
class IntSquare implements IntUnaryOperator{
 public int applyAsInt(int operand){
  return operand * operand;
}}

Можно использовать лямбда выражения:
IntUnaryOperator square = x -> { //компилятору достаточно имени интерфейса, поэтому не нужны имяМетода, типы параметров и т. д.
 return x * x; // нужны только имена параметров и тело метода(код)
};
IntConsumer print = x -> System.out.print(x); если тело метода состоит из единственного метода (и это не return), то {}можно опустить
IntUnaryOperator cube = x-> x * x * x; а если это был return, то вместе со скобками удаляем и это слово.

 К каким переменным и как можно обращаться в теле метода.

public class Demo{
 private int counter;
 public void foo() {
  IntUnaryOperator square = x -> x * x; //К параметрам лямбды. Объявлять и использовать внутри тела лямбда выражения лбые переменные 
 IntSupplier sequence = () -> counter++; //к полям того класса внутри которого объявлена лямбда. Их можно и читать и писать.
  int bonus = 10;
  IntUnaryOperator bonusAdder = (x) -> x + bonus;}} // к переменным созданным внутри того метода где объявлена лямбда. Но только эти переменные должны быть эффективно-финальными(т.е. значение им должно быть присвоено ровно один раз до создания лямбды, после меняться оно уже не может.
Из лямбды нельзя присваивать новые значения переменным содержащего её метода. Для обхода этого ограничения используют трюк с массивом одиночной длинны.
int[] counter = new int[] {0};
IntSupplier sequence = () -> counter[0]++; //т.е. ссылка на массив является эффективно-финальной, но на содержимое это ограничение не распространяется
В третих можно инстанцировать при помощи ссылки на метод:
ToIntFunction<String> intParser = Integer::parseInt; ссылка на статический метод ИмяКласса::СтатическийМетод
Consumer<Object> printer = System.out:: println; ссылка на нестатический метод КонкретныйОбъект::ИмяНестатического метода
Function<Object, String> objectToString = Object::toString; ещё ссылка на нестатический метод ИмяКласса::ИмяНестатическогоМетода. Тогда ИмяКласса должно быть передано первым параметром функционального интерфейса
IntFunction<String[]> arrayAllocator = String[]::new; ссылка на конструктор ИмяКласса::new;

Интересные и полезные default и static методы
метод получающий обратный предикату .negate();
коньюнкция двух предикатов a1.and(a2);
комбинация двух консьюмеров в третий a1.andThen(a2); вызывает сначала первое действие потом второе.
для композиций функций a1.andThen(a2) и a1.compose(a2) разница в порядке применения a1a2 и a2a1
Comporator.comparing(Math::abs, Double::compare) Math::abs будет применяться к каждому значению перед тем как выполняется сравнение, а Double::compare будет сравнивать результаты применение первого метода к исходным значениям чтобы получить финальный результат

		Stream API	
Stream(поток) - последоватьельность элементов потенциально бесконечаная с возможностью применять к ней простые и сложные(многоэтапные преобразования) без использования циклов и условных операторов.
java.util.stream:
public interface Stream<T> externds BaseStream<T, Stream<T>>{} // так же есть IntStream, LongStream, DoubleStream
Итератор простой объект который умеет выдавать элементы по одному, в отличие от него у стрима огромное количество методов. 
Итератор - средство обхода элементов
Stream - средство описания алгоритма обработки и преобразования последовательностей элементов.
 В сравнении с коллекциями
Коллекции подразумевают конечное хранение набора элементов
Stream - потенциально бесконечен
Коллекции часто предоставляют индивидуальный доступ к элементам
Stream такого не позволяет
Коллекции можно менять добовлять/удалять
Stream и применимые к нему трансформации не влияют на источник элементов
 Примеры:
int sum = IntStream.iterate(1, n->n+1) //(первыйЭлПоследовательности, функцияВычисленияСледующегоЭлементаПоследовательности по предыдущему) Возвращает  IntStream бесконечную последовательность целых чисел 
Дальнейшие методы преобразовывают IntStream и возвращают преобразованный Stream
.filter(n->n%5==0&&n%2!=0) фильтруем, оставляем только те, что делятся на 5 и не делятся на 2
.limit(10) из бесконечной последовательности берём только 10 первых
.map(n->n*n) возводим каждый из элементов в квадрат
.sum(); суммируем и получаем результат
 Использование Stream всегда состои из трёх этапов:
1 IntStream.iterate(1, n->n+1) получение стрима, откуда будут браться элементы последовательности
2 .filter(n->n%5==0&&n%2!=0), .limit(10), .map(n->n*n) это 0 или более промежуточных операций преобразования. Стрим их запоминает но не спешит выполнять
3 .sum(); это единственная терминальная операция, запускающая весь процесс вычислений и должна стать полезным результатом
4 .close() опциональный заключительный шаг - закрытие стрима. Но он обязателен только если стрим выделял какие-то ресурсы(связан с содержимым класса или директорией на диске). Можно использовать в блоке try(с ресурсами), т.к. стрим реализует интерфейс autocosable
 
 Этапы работы со Stream подробнее:
 Порождение стрима(откуда можно взять):
Set<String> vocabulary = ...;
Stream<String> stream1 = vocabulary.stream(); из любой коллекции с помощью метода .stream()
BufferedReader reader = ...;
Stream<String> stream2 = reader.lines(); из BufferedReaderа с помощью .lines();, который вернёт поток строк из данного потока символов.
Path path = ...;
Stream<Path> stream3 = Files.list(path); из директории на диске, вернёт содержимое директоии на один уровент
Stream<Path> stream4 = Files.walk(path); из директории на диске рекурсивно обойдёт и поддиректории
IntStream chars = "hello".chars(); будет содержать символы строки(получим IntStream т.к. в стандартной библиотеке нет  CharStream )  
 Стримы можно порождать динамически:
DoubleStream rand = DoubleStream.generate(Math::random); генерировать при помощи суплаера (поставщика). Supplier - интерфейс с единственным методом методом get, который должен последовательно возвращать элементы. 
IntStream integers = IntStream.iterate(0, n-> n+1); итерированием функции
IntStream smallIntegers = IntStream.range(0, 100); диапазон целых чисел в виде стрима. Вернёт 0...99
IntStream smallIntegers2 = IntStream.rangeCloosed(0, 100); диапазон целых чисел в виде стрима. Вернёт 0...100
IntStream comb = IntStream.concat(stream1, stream2); конкатенацией двух других стримов.
IntStream empty = IntStream.empty(); взять пустой стрим
double[] array = ...;
DoubleStream streamFromArray = Array.stream(array); получить стрим из массива
IntStream streamOfElements = IntStream.of(2, 4, 6, 8, 10); явно перечислить элементы стрима

  Промежуточные операции:
IntStream stream = ...;
stream.filter(n -> n > 100) фильтрация принимает предикат, последовательность будет из элементов удовлетвоярющие предикату
 .mapToObj(Integer::toString) мэп принимает функцию, которая из каждого элемента стрима делает новый элемент, потенциально другого типа(конкретно здесь мы каждое число конвертируем в строку)
 .flatMapToInt(s -> s.chars()) принимает функцию возвращающую Стрим(здесь возвращает стрим символов) Сначала каждый элемент преобразует в отдельный стрим, а потом конкатенирует все эти стримы в один.
 .distinct() убирает из стрима дубликаты
 .sorted() преобразует стрим, выстраивая элементы по порядку по возростанию(если стрим состоит из объектов, то туда можно передать компоратор) 
 .skip(3) пропустить n первых элементов
 .limit(2); ограничивает оставшиеся элементы заданным количеством
 .peek(Consumer) позволяет подсмотреть какие элементы летают на разных этапах обработки. Для отладки в Consumer удобно передавать System.out::println

  Терминальные операции(производят каой-то полезный результат):
 Запускает стрим на исполнение
IntStream stream1 = ...; 
sterm1.forEach(System.out::println); принимает Consumer, которому будут отданы все элементны, которые остались в стриме(здесь будут выведены в консоль)
IntStream stream2 = ...;
OptionalInt result = stream2.findFirst(); возвращает первый в порядке следования элемент из стрима (возвращает OptionalInt, т.к. стрим может оказаться пустым)/findAny() вернёт не первый, а тот который удобнее стриму 
Stream<String> stream3 = ...;
boolean allStringsAreAtLeast10Chars = stream3.allMatch(s -> s.length() > 10); проверка что все элементы стрима удовлетворяют переданному условию предикату/ anyMatch хоть один / noneMatchне один
Stream<String> stream1 = ...;
Optional<String> minString = stream1.min( Comparator.comparing(Sring::length, Integer::compare)); минимальное занчение стрима(Optional т.к. стрим может быть пустой) /max (Здесь Сomporator правио по которому определяется мин и макс)
IntStream stream2 = ...;
int count = stream2.count(); просто количество элементов оставшихся в стриме после применения всех трансформаций и фильтраций
IntStream stream3 = ...;
int sum = stram3.sum();	 сумма элементов
Stream<String> stream1 = ...;
List<String> list = stream1.collect(Collectors.toList()); позволяет собрать элементы стрима в новое хранилище(здесь в список), тип этого хранилища определяется параметром передаваемым в .collect()(Класс Collectors содержит много стандартных коллекторов) 
Steam<BigInteger> big = ...;
BigInteger sum = big.reduce(BigInteger.ZERO, BigInteger::add); позволяет вычислить свёртку элементов стрима, т.е. результат применения некоторого бинарного оператора к каждой паре элементов стрима, пока от стрима не останется один единственный элемент
	
   На стриме терминатльную операцию можно вызвать только один раз. После стрим не пригоден к использованию, дальше надо заново конструировать, настраивать и запусткать

	Алгоритмы при помощи стримов. Примеры:
 факториал числа n
public static BigInteger factorial(int n) {
 return IntStream.rangeClosed(1, n) порождаем интервал целых чисел от 1 до n в виде стрима
  .mapToObj(i -> BigInteger.valueOf(i)) каждое число превращаем в BigInteger 
  .reduce(BgInteger.ONE, BigInteger::multiply);} вычисляем свёртку операцией умножения

 определение того, что строка является полиндромом:
public static boolean isPalindrome(String s){
 StringBuilder leftToRight = new StringBuilder();
 s.chars().filter(Character::isLetterOrDigit)
  .map(Character::toLowerCase)
  .forEach(leftToRight::appendCodePoint);
 StringBuilder rightToLeft = new StringBuilder(leftToRight).reverse();
 return leftToRight.toString()
  .equals(rightToLeft.toString()); }		

		STEPIK JAVA COLLECTONS
 Коллекция - набор элементов(дженерики, значит тип указывается в скобках <>. Осснов
	Особенности коллекций:
-динамическая изменяемость.
-не работают с примитивами.
Есть два коренных родительских интерфейса(оба дженерики):
java.util.Collection<E>
java.util.Map<K, V>

List подразумевает обращение по индексу как массив
Set хранит в случайном порядке уникалные(без повторов) элементы
Queue FIFIO
Stack LIFO
Deque FIFO одновременно с LIFO 
Map ключ - значение.
	Иерархия интерфейсов
Collection
-List
-Set --SortedSet
-Queue --Deque
Map
-SortedMap
Collection и Map не наследуют друг друга, это два независимых корневых интерфейса
Stack не используется, вместо него рекомендуют Deque
Основные методы коллекций List<E>, Set<E>, Queue<E> унаследованные от родителя Collection<E>
int size()
boolean isEmpty()
boolean contains(Object o)
boolean add(E e)		???
boolean remove(Object o)
void clear()
 Map - не коллекции, но часто рассматриваются как таковые
----------------------------------------------------------
// пример итератора который работает в for each.
 Iterator<String> ierator = collectionName.iterator();
  while (eterator.hasNext()){
    System.out.prontln(iterator.next()); }
Основыне общие методы : .add, .remove, .get, .size, .contains,
 List работают на основе индексов, т.е. к элементу можно обратится по индексу.  
 Set не допускают дублирования 
 Queue методы: .element выдаёт элемент, который зашёл первым, или следующий в очереди; .peek тоже достаёт элемент; .pol достаёт и удаляет; offer вставляет элемент в конец очереди.
 Подробнее
 	List
 можно указать начальный размер, пустое будет null, если будем вводить больше, то просто создастся другой и расширит этот. Это динамическое расширение. 
 Основные имплементации: ArrayList<>(); LinkedList<>(); Vector<>(); Stack<>(); Collections.synchronizedList(new ArrayList<>());

 У ArrayList<>() его метод .size() имеет тип int, т.е. кол-во элементов больше чем max int не влезет. Предназначены для быстрого поиска и заполнения, почти всегда лучше остольных list.  

 LinkedList<>() работает в виде нодов(Node<E>). В реализации LinkedList<>() находятся вде (Node<E>)ссылки, которые хранят первое и последнее занчение. А сам нод хранит элемент и (Node<E>)ссылки на предыдущий и следующий элементо. Уступает во многом, хорош тем, что имплиментит очередь queue, двустороннюю очередь dequeue, удобно использовать как очередь и как stack. 
 
 Vector<>() это LinkedList<>() у которого все методы synchronized (обезопасили от возможных проблем многопоточности). Его современный конкурент Collections.synchronizedList(new ArrayList<>());

 Stack -  extends vector(обладает тем же функционалом что и vector). Только последовательность FIFO. Методы .push() .pop() .peek() - synchronized.
	
	Вопросы на засыпку:
- modify when iterate
Во время for each нельзя изменять(модифицировать), во время просто for можно. 
-sort
 Collections.sort(Listname); сортирует лист
 Для того чтобы лист(неСтандартогоТипа) сортирвался то класс типа должен implements Comparable и в этом классе надо преопределить метод ompareTo(Object o)
-binary search
 работает только с отсортированными элементами, поэтому сначала:
 Collections.sort(listName); затем в listName.get() передаём:
 Collections.binarySearch(listName, whatLookFor) И получается бинарный поиск:
 listName.get(Collections.binarySearch(listName, whatLookFor))
-to array and back
 Преобразуем наш list в массив(для примера строковый):
 String[] str = new String[listName.size()]; //Создаём массив размерностью листа.
 str = listName.toArray(str); // преобразуем лист в массив
 List<String> strListName = Arrays.asList(str); // обратное преобразование массива в лист
-list equals
 сравнение listName.equals(strListName)
 List можно использовать в Мар как ключ. это сработает, но мапы не имютабл, соответственно если добавить ещё один элемент, то всё сломается.
-toString
 System.out.pirint(listName) выдаст то же что и 
 System.out.pirint(listName.toString())  //т.е. листы можно сравнивать между собой
-vector vs sync(Collections.synchronizedList(new ArrayList<>()))
 sync - враппер он позволяет сделать безопаснее(synchronized) уже имеющуюся коллекцию, 
 sync - быстрее пробегает по коллекции
 vector - сам коллекция и будет копировать готовую в себя
 vector - быстрее добавляет элементы
-add lot of elements
 скорость добавления новых элементов: ArrayList == Vector < sync(Collections.synchronizedList(new ArrayList<>()).  
 скорость итерации(поробегания): Vector > sync(Collections.synchronizedList(new ArrayList<>()) > ArrayList
-max number add elements
 в ArrayList нельзя добавить больше чем макс значение инта (метод size - int)
 в LinkedList можно т.к. работает через ссылки(node) которых можно создать сколько хочешь (хотя метод size тоже - int)(по инту не сможем достать через .get)+

		SET
можно заполнять null-ми.
Нет .get в отличие от List.
HаshSet LinkedHashSet TreeSet.
HаshSet хранит в рандоме, в случайном порядке 
LinkedHashSet хранит в порядке добавления 
TreeSet сортирует для хранения
  HаshSet под капотом хранит добавляемое значение в виде key для HashMap
 LinkedHashSet расширяет extends HashSet, добавляя пару своих методов
 TreeSet работает на основе интерфейса NavigableMap.  Для того чтобы TreeSet(неСтандартогоТипа) сортирвался то класс типа должен implements Comparable и в этом классе надо преопределить метод CompareTo(Object o) 
// чаще всего для добавления элементов, методы .equal и .hashCode используются только в коллекциях в названии которых есть слова hash в остальных случаях используется .compareTo

	QUEUE
Имплементации:
Queue<String> a = new LinkedList<>() хорош для частого удаления элементов.
Deque<String> a = new LinkedList<>() используется как stack но в его методах можно потеряться. 
Deque<String> a = new ArrayDeque<>() как LinkedList<>()но основан на массиве а не Node и работает быстрее stack и LinkedList<>()(в качестве очереди. 
Queue<String> a = new PriorityQueue<>() сортирует, но так надо выводить чтобы сортировал: while(que.size() != 0) {System.out.print(que.remove()+" ");} 

			MAP
  Хранит ключ - значение. Основные имплиментации:
HashMap, LindedHashMap, TreeMap, HashTable, Collection.synchronizedMap(new HashedMap());
 HashMap основана на Node, в которых хранятся: хэш-ключа, ключ, значение, ссылка на следующий объект. Приемущество в быстром доступе. Значение по-умолчанию 16, максимальное 2^30
 LindedHashMap extends HashMap плюс запоминает ссылки на первый и последний элементы. Хранит порядок добавления.
 TreeMap является отсортированной коллекцией. Хранит entriy(ссылки на другие)
 HashTable тот же HashMap только с защитой от моногопоточности(методы synchronized)

 Параметр LoadFactor 0.75. Это значит что когда таблица заполнена на 75% она перехэшируется и увеличивает свой объём в 2 раза, чтбы избежать коллизий, это когда элементы с одинаковыми хэш-кодами не скалдываются в оду ячейку
 В одном и том же бакете могут быть элементы с разными хэш-кодами. Т.к. номер ячейки для хранения определяется вычислением остатка от деления хэш-кода на размерность таблицы(16, 32..)
 Увеличение производительности 8-ой джавы произошла за счёт переработки устройства Node-ов, раньше был  LinkedList, теперь двоичное дерево.
 HashMap занимает больше места чем TreeMap



---------------------------------------------------------
	методы
int size()
boolean isEmpyt()
boolean containsKey(Object key)
boolean containsValue(Object value)
V get(Object key)
V put(K key, V value)
V remove(Object key)
void clear()
Set<K> keySet()
Collecton<V> values()
Set<Map.Entry<K, V>> entrySet()

		ТЕПЕРЬ ПОДРОБНЕЕ КАЖДУЮ. LIST
	Методы интерфейса List<E>
унаследованные
int size()
boolean isEmpty()
boolean contains(Object o)
boolean add(E e)		???
boolean remove(Object o)
void clear()
+ новые
E get(int index)
void add(int index, E element)
E remove(int index)
E set(int index, E element)
int indexOf(Object o)
  
 Нельзя создать объект List, но можно создать объект его наследников: ArrayList и LinkedList. Их различия в механизме ввода элементов. Но общий родитель (унаследованные методы) позволяют использовать их одинаково.
 У ArrayList - автоматически расширяемый массив. Может быть любого (даже null) типа.
У него есть три перегурженных метода: ArrayList(по-умолчаниюPазмерность10),  ArayList(Collection<? extends E> c), ArrayList(int initialCapacity) 
 У LinkedList есть два пергруженных метода:
LinkedList(), LinkedList(Collection<? extends E> c)
 Полезные операции.
 for (String name : ArrayList/LinkedList) {
 System.out.println(name); }
 Object[] objArray = ArrayList/LinkedList.toArray(); /преобразование list в массив объектов
 Srting[] strArray = ArrayList/LinkedList.toArray(new String[0]); /преобразование list в массив строк
 List<String> list = java.util.Arrays. asList("one", "two", "three"); преборазование массива в list
 ArrayList/LinkedList.subList(a, b);  кусок списка где: a- с какого элемента включительно, b- до какого не влючая.

		Queue
First In First Out. Доступны только две операции. Можно добавлять новые в конец очереди enqueue и удалять имеющиеся из начала очереди dequeue.
Наследуется от Collection.
	Методы
boolean add(E e) вставляет элемент если возможно, возвращает тру или exception
boolean offer(E e) просто вставляет элемент если возможно
E remove() возвращает и удаляет элемент из головы очереди, exception если пусто
E poll() возвращает и удаляет элемент из головы очереди, null если пусто 
E element() возвращает но НЕ удаляет элемент из головы очереди, exception если пусто
E peek() возвращает но НЕ удаляет элемент из головы очереди, null если пусто 

		Stack
Last In First Out.  Доступны только две операции. Добавить элемент в конец очереди push и удалить элемент из конца же pop
Но его не рекомендую использовать. Предпочтение следует отдавать двусвязному Deque
	Методы
.push(E e) добавляет 
.pop() удаляет
		Deque
java.util.Deque<E> extends (расширяет) java.util.Queue<E>. По сути это двусвязный список и он позволяет как FIFO так и LIFO (работать с обоими краями очереди). Есть два варианта реализации этого интерфейса ArrayDeque и LinkedList. Следовательно эти два класса могут применятся как Queue (FIFO), Stack (LIFO), and Deque (Double-Ended Queue)
	Методы
 Работа с началом очереди
addFirst(e) добавить если не может то бросает exception
offersFirst(e) добавить если не может то возвращает какое-то значение
removeFirst() удалить если не может то бросает exception 
pollFirst() удалить если не может то возвращает какое-то значение
getFirst() посмотреть элемент если не может то бросает exception 
peedFirst() посмотреть если не может то возвращает какое-то значение
 
 Работа с концом очереди
addLast(e)  добавить если не может то бросает exception
offerLast(e) добавить если не может то возвращает какое-то значение
removeLast() удалить если не может то бросает exception
pollLast() удалить если не может то возвращает какое-то значение
getLast() посмотреть элемент если не может то бросает exception
peekLast() посмотреть если не может то возвращает какое-то значение
 
		Set
 Хранит только уникальные(в единственном экземпляре) элементы. Невозможно получить элемент по индексу. Интерфейс Set<E> наследуется от интерфейса java.util.Collection. Три реализации Отличаются порядком хранения: HashSet(для сортировки использует метод Object.hashCode()), LinkedHashSet(в порядке добавления), TreeSet(отсортированы в порядке возрастания), (есть ещё 56EnumSet). Своих методов нет. только унаследованные.
int size()
boolean esEmpty()
boolean contains(Object o)
boolean add(E e)
boolean remove(Object o)
void clear()
 		HashSet (быстрее остальных Set)

//Хэш-функция - функция сужающая множество значений объекта до некоторого подмножества цулых чисел.
Этот класс реализует интерфейс Set, поддерживаемый хеш-таблицей. Это не дает никаких гарантий относительно порядка итераций множества. Для сортировки использует метод Object.hashCode()(должен быть переопределён в классах объектов, заносимых в HashSet. Как и ArrayList() имеет два основных конструктора: пустое множество - public HashSet(), и множество из элементов коллекции - public HashSet(Collection c)
	Методы
Iterator iterator()
int size()
boolean isEmpty()  
boolean contains(Object o)
boolean add(Object o) добавялет только если такого ещё нет.
boolean addAll(Collection c)
Object[] toArray()
boolean remove(Object o)
boolean removeAll(Collection c)
boolean retainAll(Collection c) (retain - сохранить) Выполняет операцию "пересечение множеств"
void clear()
Object clone()
		LinkedHashSet
 Расширяет HashSet. Не добавляет новых методов. Поддерживает связанный список в порядке добавления
		TreeSet
 Расширяет HashSet. Не добавляет новых методов. Хранит в виде "дерева" по возростанию.
		SortedSet
 Позволяет сортировать элементы множества. Сортировку можно изменить через поведение Comparable.
	Методы
Comparator<? super E> comparator() возвращает используемый comparator, если не использовался, то null.
subSet(Object fromElement, Object toElement)
tailSet(Object fromElement)
headSet(Object toElement)
Object first()
Object last().

		Map<K, V> (generic K-тип ключа V-тип значения)
 "Ассоциативный массив". Не наследуется от интерфейса Collection. Хранит в контейнере два значения "Ключ" и "Значение", и то и другое - любые объекты. Позволяет искать объекты по ключу. Ключи уникальны, значения могут дублироваться. Основные реализации: HashMap(макс. скорост, не упорядочена), TreeMap(сортирует автоматом по возрастанию), LinkedHashMap(порядок вставки, не быстрый) 
	Методы
int size() - возвращает количество пар ключ-значение в отображении
int hashCode() - возвращает хэш-код вызывающего отображения
boolean isEmpty() - false если вызвающее отображение пусто
boolean equals(Object o) - возвращает true если о - отображение, содержащее одинаковые значения.
boolean containsKey(Object key) - проверяет есть ли key
boolean containsValue(Object value) - проверяет есть ли value
V get(Object key) - отображает значение связанное с key
V put(K key, V value) - помещает элемент в вызывающее отображение, заменяя прошлое значение. null если ключ не существовал(иначе выводит значение) 
V remove(Object key) - удаляет элемент с ключом key
void putAll(Map<? extends K, ? extends V>m) - помещает все значения из m в отображение.
void clear() - удаляет все пары ключ-значение.
Set<K>keySet() - возвращает набор содержащий ключи вызывающего отображения.
Collection<V>values() - возвращает коллекцию, содержащую значения отображения.
set<Map.Entry<K, V>>entrySet()  - возвращает набор, содержащий все значения отображения. Набор из объектов Map.Entry
V putlfAbsent(K key, V value)
V getOrDefault(Object key, V defaultValue)
для TreeMap есть: subMap(Object fromElement, Object toElement)
subMap(Object fromElement, Object toElement).lastKey()/firstKey()
tailMap(Object fromElement).lastKey()/firstKey()
subSet(Object fromElement).lastKey()/firstKey()



    Теория из видосов немчинского.
Путаница версий java: 1; java 2 - java 2(1.4); 5(java2 (1.5)); 6(java 2 (1.6))...
cms content menegment systems (системы управления контентом) WorldPress Joomla
для микросервисов используют spring.
	парадигма - способ мышления (восприятия).
компиляция - превращени исходного кода в машинный кода / компайл тайм - процесс превращения исходного кода в бинарный (javac поиск зависимостей библиотек) \ ран тайм
API application programming interface - то через что работают с объектом должно быть public (остальное private). Этим определяется уровень доступа (инкапсуляции). Static - значит что это общий (метод/поле) для всех обектов этого класса. То что не Static относится к конкретному эеземпляру объекта. (лучеше не использовать).
JDBC (java data base connectivity) драйвер для баз данных.
JPA java persistans architect 
не стоит тратить сейчас время на Swing/SWT и FX (для ui). Отдать пердпочтение веб интерфейсу и спрингу.
JSP java server pages (для веба)
Доменная модель. начинаем писать приложение с "декомпозиции предметной области" - выписываем все объекты которые будут задействованы определяем их свойства. дальше бизнес логика(логика взаимодействий между объектами), DAO (data access logic) работа с базой данных, UI слой. Это интерпрайз паттерн domain model.   	
---------
	
Раннее связывание - мы знаем или передаём известное значение Shape a = new Circle(20)
Позднее - мы узнаем после компиляции int res = circle.square();
 класс наследник не обязан реализовывать все методы родителя? а наследник интерфейса(от интерфейса) должен реализовывать все методы родителя и так же деда, прадеда, ...
 Класс может содержать 4 виды внутреннийх классов: 
-внутренний каласс;
-локальный внутренний класс; (находится внутри метода)(метод возвращающий объект класса - фабричный метод) (может быть безымянным, 
-статический внутренний класс; (имеет доступ только к статическим полям и методам внешнего класса).
 Многопоточность. Класс thread Runnable
 java.io. - файловые потоки ввода-вывода.
 str.split(" ")
 Рефлексия java.lang.reflect. Constructor/Field/Method/Modifier (всё через массив).
 сериализация (обязательно - implements Serializable) разбивка на байты для передачи. десериализация - сборка из байтов. 
-анонимный внутренний класс;.
  Generic - контейнеры, коллекции. Доступ: прямой и последовательный. (java.util....)
Set не может хранить одинаковые значения. Разница между hash/tree/list set в варианте хранения (последовательности/упорядоченности) элементов. 
 list offer статвит элемент в очередь. poll получаем и удаляем из очереди, peek получаем не удаляя.
 Vector
 Stack последний зашёл - первый вышел.
 map (key + value) : hashTable, LinkedHashMap, TreeMap. Entry<obj : obj> entry : map.entrySet() - для перебора.

Как переопределять метод equals в Java
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/
if (obj == this) {
/*и верните */ return true;}
   модификатор static применяется для создания методов и переменных класса;
модификатор final используется для завершения реализации классов, методов и переменных;
модификатор abstract необходим для создания абстрактных классов и методов;
модификаторы synchronized и volatile используются в Java для потоков

Static 
-вызывпется без создания объекта класса: имяКласса.имяСтатикМетода();
-статические методы нельзя переопределить;
-статические объекы могут ссылаться только на статические переменные
-статические методы/переменные общие дял всех эеземпляров класса.

int num = sc.nextInt(); (если инициализируем не константой, то надо разделять объявление и присвоение.) int num;   num = sc.nextInt();
stack(thread) memory, heap, permanent (размеры этих объектов можно поменять в настройках виртуальной машины)
в heap (куча) (создаются и хранятся объекты, орудует сборщик)
структура данных stack(thread) реализует правило LIFO
frame кусочек памяти выделяемый под выполнение. В нём хранится адрес возврата в стек (return), байткод выполняемого метода, здесь же выделяется память под локальные переменные метода.
пул литералов


----------------------------------------------------------------------------------------------------------------------------------

					Из курсов "Изучаем Java"
У объкета методы - поведение, поля - состояние.
не явное приведение типов работает когда не теряются данные.
явное приведение - если обрезаем 		
Имя pubclic класса должно совпадать с именем файла. Public класс может быть только один. Только паблик классы видны в других пакетах.
Поля должны быть private (если не final)
Имя класса - существительное. Интерфейса - прилагательное.
Класс может быть только либо без модификатора доступа, либо public. Другие модификаторы: 
strctfp (strictFloatinPoint) можно определять точность вычисления float переменных во всех методах.
abstract - нельзя создать экземпляр. (a. метод может быть только в а. классе, но в а. классе може т не быть а. методов) а. метод не содержит тела(нет {...} сразу ; // abstract void method();) наследники а. класса обязаны переопределить все а.методы. а. класс может наследоваться от обычных методов, просто следует знать.
final - нельзя наследовать или менять.
либо abstract либо final.
Интерфейс используется для описания поведения. Они полностью abstract но указывать это ключевое слово не надо, оно и так подразумевается. методы - puclic abstract, поля - final. Интерфейсы implements а не extends, поэтому их может быть много у одного класса.

	модификаторы доступа для методов
private - только в этом классе
protected - только в этом классе и наследниках мы можем её менять !!!! проверить что от он как и default виден на уровне пакета. 
default - в других классах всого package
public - везде 																																																														
	модификаторы переменных
private protected default public
и ещё в дополнение: 
final (делает неизменным, константа. Можно задать значение напрямую или конструкторе) 
static (одно значение на все классы, возможность получать доступ без создания объекта, можно менять значение) 
transient(убирает поле из сериализации, процесса разбиение на байты для передачи данных) 
volotile(многопоточность, переменную читать из памяти, а не кэшированую версию. Обычно используется когда один поток пишет, а остальные читают) 
 поля инициализируются по-умолчанию, а переменны в методах(локальные) надо вручуню. Поля и локальные могут иметь одинаковое имя и не мешать друг другу(shadowing, перекрытие).
параметры хранятся в стэке(быстрый доступ) (хип выделяется под)
 
	модификаторы метода
void (либо тип возвращаемого значения (return))
final (не измеянется, нельзя переопределить)
static (используется без создания экземпляна класса, не может содержать не static поля)
abstract (без тела, не бывает final/static, должен переопределяться в наследниках)
synchronized (может выполняться только в одном потоке)
strictfp (точность float, редкий)
native (методы реализованные на других языках. сами не используем, можем встретить) 
в параметрах varargs... должен быть только один и последним в списке
 
	Конструктор
 Метод у которого из сигнатуры есть модификаторы доступа и имя совпадает с именем класса, параметры. Используется для инициализации. Можно переопределять сколько угодно с разными параметрами и телами.
 Создаётся по-умолчанию c модификатором доступа как и класса, без параметров и телом: {supe();}. Если мы определили хоть один, то по-умолчанию уже не создаётся. В теле supe(); добалвяется постоянно и неявно(не видно). Благодаря этому в первую очередь вызывается конструктор родителя и по нисходящей. 

	Enum (перчисление)
enum name {first, second, ...} // можно без ";"
можно определять в классе, вне класса(public/default), но только не в методе
по сути, это краткая запись класса хранящего final поля.
может содержать в себе поля, методы и конструкторы:
 enum name {first(f), second(f);
  int f;
  name(int f){ this.f = f;}
 }
метод можно переопределить для отдельного значения в перечислении.
enum name {first(f), second(f), third(f) {
  String method(){
	return otherMethod; }
 };
   Sting method(){
	return oneMethod;}
}

	Overload перегрузка методов
 Метод с одинаковым ИМЕНЕМ но разными сигнатурами: модификаторами доступа, модификаторами метода, возвращаемыми типами, принимаемыми параметрами, эксепшенами. Т.е. метод который может принимать разные значения. 
 Метод с одинаковым именем находящийся в наследном классе тоже явяется перегуженным, хоть и кажется что он переопределён.
 Последовательность приоритета преобразований short(из типов котороые могут встретиться):
short int long double float Short(wrapper) Object short...(massive)(1) автоприведение к примитивам, 2) обёртка(автобоксинг), Object,3) массив).

	Overriding переопределение методов
 У переопределённых методов могут быть разные:
модификаторы доступа, но только при условии что насленик расширяет видимость. 
модификаторы метода.
exceptions опять же при условии что у наслендика exception будет наследником родительского exctption.

static вообще нет смысла использовать. 
тип возвращающего значения должен быть одинаковым, либо соответствовать иерархии (родитель-наследник будут приняты как одинаковый тип).
// Parent a = new Parent(); Parent b = new Child(); разобрать почему так.

	STATIC
 Статическими могут быть поля, методы, инициализаторы(код в конце, не сработавший у меня) 
Статические поля и методы нужны чтобы иметь некоторые переменные на уровне экземпляра класса.
Статическая переменная создаётся при первом обращении к классу. Статический метод можно создавать

	блоки инициализации (не работающие у меня)
static { code } и обычный{ code }. Их может быть много и вызываются они по порядку 
Выполняются: static { code } при первом обращении к классу, обычный { code } при каждом вызове конструктора класса( вызывается сразу после super(); )  
 
 	
Двумерный массив можно указать так:
int[n][] i; или так int[n] i[]; или так int i[n][]  

	Wrappers
 Cсылочные типы хранят ссылки на объект в heap, String хранятся в пуле стрингов. Для сравнения используется equals(сравненти внутренних значений)
 int a = new Integer("4"); wrapper Integer распарсит строку и сохранит целочисленное значение в int.
Три самых частые методы 
int a = Integer.parseInt(" 4"); возвращает int
Integer b = a.valueOf("4"); возвращает Integer
short s = a.shortValue();  возвращает требуемый примитив.
 Автоупаковка - при действиях над обёрткой происходит автоматическое преобразование к примитиву
, действие над примитивом, обратное преобразование к обёртке.

 	Garbadge Collector
 Object ob = new Object(); Создаём ссылку ob и создаём новый объект посредством new и записываем ссылку на этот объектв ссылку ob.
 Мусорщик постоянно ищет ссылки на объекты. Когда находит объект без ссылок(на этот объект).
 Ссылка которой присвоили значение null - кандидат на удаление мусощиком
 Вызов мусорщика System.gc(); никогда не используется но знать надо что послевызова System.gc() мусорщик может либо запуститься, либо не запуститься ( на своё усмотрение). Запуск System.gc() вызыветм метод объекта finalize();, который есть у всех методов(наследство от Object)

 	Операторы
 a == a1 сравнение примитивов
 а.equals(a1) сравнение ссылочных типов (объектов)
 а.instanceOf(a1) является ли объект а наследником а1
 swich может принимать примитивы, enum, String

	Try/Catch
 Try не может быть без одного из двух: либо catch либо finally. Catch может быть множество для разных исключений, агрументы exeprions должны быть различны и соблюдать иерархию: от наследника к родителю. В catch можно вложить ещё try/catch-и. Finally выполняется всегда.
 Важна иерархия Exception-ов
 Throwable -> Error(мы бессильны)/Exception -> RuntimeException(unchecked)/(InputOutput)IOException(checked) 
 tyr/catch луше использовать когда работаешь сам и для себя, throws Exception - когда другие могут пользоваться твоими классами и методами(ты показываешь им что тут может быть вызвано исключени, обарбатывайте сами.)
 Unchecked Error()/RuntimeException() нет необходимости обрабатывать (
 Checked Throwable()/Exception()/IOException() надо обрабатывать самостоятельно (ошибки программиста)
 void method() throws IOException {throw new IOException();} - предача проблемы на верхние уровни(туда где метод будет вызываться)
 т.е. при вызове method его необходимо обернуть в try/catch(Exception e) вместо (Exception e) указываестя либо само исключение(в нашем случае IOException) либо его родители.
 нихера не ясно разобрать толком в других источниках Exceptions

 assert(условие) - проверка условия. Если выполняется условие, то срабатывает asserException. Используется как черновая проверка для себя. По умолчанию от отключены. Можно запустить через терминал с аргументом -ea (enable assert) (java -ea Class) . Также можно указать -еа в Run/Debug configurations->Configuration->VM options.

 String - неизменяемый класс.
 String s1 = new String("abc"); s1.concat("def"); - не изменят строку s1.
 String s2 = s1.concat("def"); - создаст новую строку s2 со значением abcdef(s1+def). 
 Для того чтобы изменять одну и туже строку используют классы StringBuilder StringBuffer. Они идентичны, отличаются тем что StringBuffer - все методы Synchronized.
 StringBuilder sb = new StringBuilder("fed"); sb.append("cba"); выведет fedcba.
 
	 Работа с файлами.
 File file = new File("temp.txt"); - создаёт файл в памяти. Интересные методы(bool) - file.isDirectory(); file.isFile(); file.exist(); file.createNewFile(); file.mkdir(). 
 FileWriter fileW = new FileWriter(file); fileW.write("srt1\n"); fileW.flush(); fileW.close();
 FileReader fileR = new FileReader(file); char[] chars = new char[20]; fileR.read(chars); недостаток в том, что надо создавать массив чаров, и указывать длинну этого массива. Как альтернативу используют: 
 BufferedWriter bwriter = new BufferedWriter(fileW); bwriter.write("str3"); (вместо"\n") bwriter.newLine(); bwriter.flush(); bwriter.close();
 BufferedReader breader = new BufferedReader(fileR); while(breader.ready()){sout(breader.readLine())};

	 Serialize/Deserialize
 Класс должен имплементить интерфейс Serializable. Пример, по другому никак:
 class User implements Serializable {};
 public static class main(String[] args) throuws Exeption{ 
        User user = new User();
        FileOutputStream fOS = new FileOutputStream("tempFile");
        ObjectOutputStream oOS = new ObjectOutputStream(fOS);
	oOS.writeObject(user);
	oOS.close();
    FileInputStream fIS = new FileInputStream("tempFile");
    ObjectOutputStream oIS = new ObjectInputStream(fIS);
    User newUser = (User) oIS.readObject();
    oIS.close();
 
 Статические поля не сериализуются, потому что мы сериализуем/десериализуем объект, а статическое поле тоносится/принадлежит к классу.
 Поля которые не сериализуются(не надо/нет возможности) помечаются transient. После сериализациии им присваивается значение по-умолчанию. Транзиентные поля не должны учавствовать в (переопределении) equals()/hasCode()
 Классы наследники тоже могут сериализоваться. Но если его родитель не буедт implement Serializable, иначе он(родитель) определится как transient и перепишется со значениями по умолчанию. 

java.util.Date; 
Date date = new Date(); текущая дата
Date date = new Date(0); в скобках количество милkисекунд с 01.01.1970

java.util.Calendar;
Calendar cal = Calendar.getInstance();
cal.setTime(date);
cal.add(Calendar.WEEK_OF_MONTH, 1); //date + 1week

DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT); // legasy
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy") // позволяет выбирать вид вывода.
 распарсить дату можно так:
Date newDate = sdf.parce("01.01.2020");

	HashCode & Equals
method a.toString(); можно заменить записью sout(a + "");
hashTable 
hashCode - возвращает адрес объекта в памяти.
equals(Object obj){return (this==obj);} проверяет находятся ли объекты в одном и том же месте памяти. проверка на эквивалентность
 при переопределении этих методов используют все параметры(поля) переопределяемых классов
hashCode переопределяют с целю получения максимлаьного разброса возвращаемых значений.(это номера ячеек в которых будут храниться значения, а они могут складываться в одину ячейку) //hashCod-ы могут повторяться.
 А когда они повторяются применяется метод equals()
Если hashCod-ы равны это не значит что equals() тоже равны, но
если equals() равын то и hashCode тже равны 

 	Collections
Класс Collections Класс Arrays  implement-ся от Интерфейса Collection. 3 вида упорядоченые(ordered) неупорядоченые(?) отсортированные(sorted)
Collection col = new ArrayList(); 
 Mетоды
 .add();
 .remove();
 Iterator i = col.iterator();
 while (i.hasNext()){ sout(i.next()); 
List работакт по индексу. У интерфейса List есть метод .set(index, "value"); вставляет значение "value" на место index ( .get только у List)
У очередей Queue .peek() достаёт элемент но не удаляет, .pol достаёт и удаляет из коллекции. 
У Set уникален выводом уникальных элементов. .put()задаём ключ-значение .get(достаём значение по ключу .size(размер). Что бы пробежаться: Set s = col.entrySet(); for(Object i : s){sout(i)}; (keySet-пробежаться только по ключам). 

	Сортировка коллекции
Set s = new TreeSet(); примитивы и String он знает как сортировать. для остальных классов необходимо:
class OurClass implements Comparable<OurClass> //в классе имплементим компарабал 
//и оверрайдим метод компaрту.
@override
pulbic int compareTo(OurClass obj){
 return this.поле - obj.поле; (простейшее сравнение поля класса <0<. В реальности всё гораздо сложнее и надо задействовать все поля класса).
  Если нет возможности добавить классу implements Comparable. Необходимо создать  класс:
class CompareOurClass implements Copmparator<OurClass>{
@override
public int compare(OurClass o1, OurClass o2){ return o1.поле - o2.поле} //те же действия только через посредника(вероятнее всего ещё и через get/set: return o1.getПоле - o2.getПоле.).
 И теперь этого посредника надо представить Sety:
CompareOurClass coc = new CompareOurClass();
Set s = new TreeSet(coc); // можно короче Set s = new TreeSet(new CompareOurClass());
	
	Списки List
Хранят информацию о добалвленных элементах в виде индексов.
Vector - synchronized ArrayList;
ArrayList.DEFAULT_CAPACITY = 10; при создании нового по умолчанию создаётся 10 элементов (int).                                                                
ArrayList очень быстрый для пробегания(на основе массива)
LinkedList - двунаправленный связанный список хранящий node ссылочную информацию на следующий и предыдущий элементы.
LinkedList (не подтверждено) хорош для работы(вставки/удаления) с выборочным элементом. (подтверждено) хорш для работы очередей добавлять/удалять первый/последний элемент.
 
	Queue
LinkedList - упорядоченная очередь(как ввели)
чтобы отсортировать LinkedList надо:
 Queue ll = new LinkedList();
 List list = (List)ll; Collections.sort(list); while(ll>0){sout(ll.poll())};
Но лучшеиспользовать класс:
PriorityQueue - отсортированная очередь.(сортировка происходит сразу при добавлении элемента).

	Map<K, V>
Есть 4 типа 
HashMap()(неупорядоченый)(у разных объектов может быть одинаковый хэшкод); 
HashTable() тоже неупорядоченный synchronised HashMap();
LinkedHashMap() ordered(упорядоченный) HashMap(), двусвязный список; 
TreeMap() отсортированный по принципу red-black tree; 
 пример:
Map map = new HahsMap();
map.put("1", "one");
map.put("2", "two");
sout(map.get("2")); // вернёт two
  Для всех ключей необходимо переопределять методы equals/hashCode
основные методы put, get, remove, size, isEmpty
значение по умолчанию 16 (т.е. побитовый сдвиг 1 << 4 )
максимальное значение ~2^30 (1 << 30);

	Set не хранит повторяющиеся значения
3 типа
HashSet(); неупорядочен, в основе просто Мар
LinkedHashSet(); упорядочен, в основе LinkedHashMap
TreeSet(); отсортирован, в основе TreeMap
основные методы size isEmpty add remove 


	Gentric <обобщённые типы> параметризованные или типизированные  
 Описание Generic класса:
 pulic class Main <T> 
 Описание Generic метода:
 <T> T method(T type){ return type; } <T>тип метода, T = void, T Type - тип принимаемого значения
 Описание Generic переменной
 Т var;
  Generic типов ожет быть несколько через запятую <T, U, D>
может наследоваться и имплементиться. <T extends SomeClass & SomeInterface & OtherInterface>
 Как недостаток - у Generic типов мало методов, соответственно их используют для хранения данных в коллекциях
Не может быть static
НЕльзя создавать массивы
 В коллекциях можно 
<T extends Class> по нему можно пройти, добавить нельзя
<T super Class> можно пробегаться и добавлять наследников
	
		Inner Classes
 Внутренний класс имеет полный доступ  даже к private полям совего внешнего класса и наооборот. Но их нельзя связать статически, необходимо создавать метод либо объект через которые их связывать. Для связи с посторонним классом необходимо использовать метод внешнего класса, для связи с внешним - объект(эеземпляр) внешнего.
 Отдельно есть статический "внутренний" класс, но он не внутренний, не имеет доступа к полям внешнего (за исключением статических полей).
 Классы внутри метода. Экземпляр этого класса можно создать только после объявления класса и использовать его можно только внутри объявленного метода.

	Анонимные классы.
 Переопределение меода прямо по ходу объявления объекта.

	Клонирование.
Class object1 = object; кладём object в новую ссылку object1
Class object2 = object.clone(); создаём новый object2 - копию object. //только обязательно: Class должен implement Clonable.
Это поверхностное клонирование. Глубокое клонирование - кода отдельно клонируются все внутренние объекты.

	Рефлексия.
 Возможность у любого объекта получить экзепляр Class объекта class. С его помощью получаем доступ к конструктрам, методам и полям.(даже приватным через .setAccessible(true) .setНужныйТип(кому, какой);
.getMethods - досту к методам .getDeclaretMethods - доступ ко всем методам (с любым модификатором доступа). можно передать значение в метод method.invoke(куда, что);
Основные выводы: .getName(); .getType().getName(); .getReturnType();
 Пример.  Так можно получать доступ к  конструкторам, полям и методам. 
SomeClass sc = new SomeClass();
	Class clss = sc.getClass();
	Class clss1 = SomeClass.class;
	Constructor[] constr = clss.getDeclaredConstructors();
	for(Constructor constrs :constr ) {
		System.out.println(constrs.getName());
		Parameter[] param = constrs.getParameters();
		for (Parameter para : param) {
			System.out.println(para.getName());
			System.out.println(para.getType().getName());
		}

Для методов и полей можно ещё вызвать список модификаторов:
 Modifier.toString(method.getModifiers());

	Что следует знать
java swing не надо, android возможно, web надо
 java 8 лямбда
git maven JUnit Hibernate Spring SQL jpql HTML CSS javascript(w3schools.com учебник) jquery
	Что надо знать перед собеседованием.
ООП, полиморфизм, разница между интерфейсом и абстракт классом, сборщик мусора, ИСКЛЮЧЕНИЯ, стрингбилдер/стрингбуфер, сериализация, КОЛЛЕКЦИИ ЭКВАЛС ХЭШКОД, МНОГОПОТОЧНОСТЬ, ГИБЕРНЕЙТ, СПРИНГ(БИНЫ), скюль, html/css, english.

	компиляция в консоли
javac -d to -cp CPfrom where.java //с classpas чё-то намудрили
java -cp NOWto  where.class 
jar -cf Myjar.jar what
java -cp NOWto:Myjar.jar where.class
jarфайл можно скопировать/переместить в папку джавы ../jre/lib/ext. тогда не надо указывать :Myjar.jar
jar -tf Myjar.jar - содержимое
 
	чтение из консоли
Для этого есть специальныe классы: 
Console console = System.console(); String s = ""; s = console.readLine(); - terminal
читаем ввод из консоли.
Scanner scanner = new Scanner(System.in); Stirng s = ""; s = scanner.nextLine(); - output console.

	Многопоточность
  Создание потоков.
Для создания необходимо переопределить метод Run. Есть 2 варианта:
1) class MyThread extends Thread { @Override public void run(){ sout("bla");}}
.создание объекта: MyThread a = new MyThread();
.запуск(создание) потока: a.start();
2) class MyRunnable implements Runnable { @Override public void run(){sout("bla-bla");}} 
.создание объекта: MyRunnable a1 = new MyRunnable(); 
.запуск(создание) потока: Thread thread1 = new Thread(a1); thread1.start();
 .run() - вызов метода.
 .start() - вызов метода в новом потоке (создаёт поток и помещает в pool(бассейн)).
 Если вызвать оба этих метода то они запустятся в произвольном порядке.
 меthod.start() нельзя вызвать повторно. Для создания нескольких потоков надо создать несколько объектов Thread и вызвать у каждого .start()
 сокращённый вызов:
 new MyThread().start();
//у нового потога есть свой стек вызовов, который начинается с метода run();
 Методы потока:
Thread.start();
Thread.sleep(1000);(статический) вызывает interruptedException.
Thread.interrupt();
Thread.yield();(статический) возвраащет потоко из 3 в 2 и пытается запустить что-либо другое. "погодь, запусти другой"
Thread.join();(не статический) - прекращает свое выполнение пока не завершится какой-то другой.
 статический - можно запустить только на текущем потоке
 не статический - на объекте.
Состояния потока
1 new
2 runnable (в пуле, на очереди, но ещё не выполняется)
  не стабильно между 2 и 3.преходят туда-обратнo, переодически(но не обязательно) попадая в wating/blocking/sleepin состояния (выходя из данных состояний поток попадает в 2)	
3 running (выполняется)
4 dead
  synchronized - запрет на выполнение других потоков до завершения текущего. //monitor очень похож по поведению: lock на объекты.
 Синхронайзд может быть метод, самостоятельный блок synchronized(this){},
 Синхронайзд работает с конкретным объектом, используется если несколько потоков работают с одним объектом и могут мешать друг другу.
 Статическая синхронизация отличается от обычной, она выполняется на уровне класса (не объекта). Они могут выполняться одновременно, потому что lock у них разные. Но делать так нельзя. Не надо их смешивать. 
 volatile применяется к переменной, которую используют несколько потоков. volatile объект(поле, переменная) не кешируется выполняясь в потоках, а пишется(работает напрямую) в основную память(main memory). Работает быстрее и мене затратно чем synchronized.
 атомарные переменные: атомарная операция - операция в одно действие. Для использования примитива в нескольких потоках, что бы они не мешли друг другу.java.util.concurent.atomic - атомарные обёртки.
 Синхронизированные коллекции. 
 List a = Collections.synchronizedList(new ArrayList<>()); - делает все методы синхронайзд.

 Deadlock (зависание)
происходит когда 2 ресурса ссылаются друг на друга и соответственно мешают друг другу. ( если 1 вызывает 2 а 2 вызывает 1 то всё виснет, потому что нельзя вызвать 1 пока не закончится выполнение предыдущего 1)
 Notify (уведомить) чтобы постоянно не проводить проверку на нужность поток переходит в waite и ожидает notify

























sout(Thread.currentThread().getName()); - выводит имя потока в котором вызван







































из консоли запуск java Main param1 param2 прямая передача параметров(args) в метод main(String[] args) 

 класс должен запускаться без main класса /попробовать в идее
class WithoutMain {static {System.out.println("Start without Main method");System.exit(0);}}
попробовал - не работает.
ctr+shift+l - eclips hot keys


