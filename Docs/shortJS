
нет разницы в виде ковычек.
разница == и === второе строже и сравнивает втом числе и типы данных
больше нет var только let и const.
встроенные способы взаимодействия: consol.log('...') alert('...') confirm('...') prompt('...','') //let a = prompt('...','') -> a == ...;
массив - упорядоченный набор разнотипных данных. отличается от джава.
полученные от пользователя данные только типа стринг
объявление функции function declaration function a (){...} // как и var можно использовать до объявления в коде 
функциональное выражение  function expression let a = function() {...}
переменные глобальные в коде и локальные внутри функции могут имень одинаковые имена!!
типы данных:
Простые:
1числа, 2строки, 3логический(boolean), 4true/false, 5null()не существует вообще), 6undefined(существует,но не определено), 7Symbol, 8BigInt(>2встепени53).
Объекты/Спец.объекты: 1Массив, 2Функция, 3ОбъектДаты, 4РегулярныеВыражения, 5Ошибки.
Объекты/Обычные объекты
!!!Использование косых кавычек на клавише тильда `` -> let name; `Hello ${name}.` == "Hello "+name+"."  
это бэктики интерполяция (как-то так)
способы обращения из js документа к html странице :
устаревшие
let a = document.getElementById('...') (получение уникального идентификатора, т.е. по Id)
let a = document.getElementsByTagName('...')[0] //HTMLCollection это псевдомассив, а [0] первый элемент
let a = document.getElementsByClassName('...')[0]  //HTMLCollection это псевдомассив, а [0] первый элемент
популярные
let a = document.querySelector('.selectorname') //обращение только к первому элементу
let a = document.querySelectorAll('.selectorname')[0]  //HTMLCollection это псевдомассив, а [0] первый элемент  И только он обладает методом FOREACH
В последних вариантах в скобках надо точно указывать селектор, т.к. в вызове не указывается к какому типу обращаемся. // указан через точку т.к. обращаемся к классу.
события - всё что присходит на странице по воле пользователя от нажатия кнопок на клавиатуре вплоть до перемещения курсора.
обработчики событий - ловят все эти действия могут относиться к только определённым html элементам либо ко всем
обращение к классу через точку
события можно использовать тремя способами: 
1 создать функцию в jsдокументе и вызвать её прямо в html коде // для сырых тестов
<div onmouseenter="function()"></div>
2 вызов функции в js документе // плох тем что изменить после использования нельзя
chooseBtn.onmouseenter = function; // без скобок т.к. это не вызов а указание что надо будет вызвать
3 тот способ который сейчас используется с ОБРАБОТЧИКОМСОБЫТИЙ addEventListener 
chooseBtn.addEventListener('mouseenter', function () {
    логика функции    
}) // здесь museenter без on
элемент.textContent = "..." - изменение текста
modal.style.display = 'block'/'none' - элемент.стили.значение = показать/закрыть
text.value = '...' - динамический ввод текста // этот текст будет сразу и сам добавляться к тому который вводя. применимо только к input событию
// onmouseenter при наведении мыши/ onmouseleave когда убрали мышь, click, input
ДОМ - объектная модель документа
первой строкой js документа указываем 
window.addEventListener('DOMContentLoaded', function() {
    здесь вся страница
});
что не позволяет нашему коду запуститься пока весь ДОМ не подгрузился на HTML странице (в данном случае все тэги, картинки игнорятся)
let a = document.createElement('div'/'h1'/'button'); - создание нового 'div'/'h1'/'button' не нарушая структуры HTML документа
a.classLIst.add('другая функциональная переменная')
document.body/div/class.appendChild(a); вставляет в конец тэга body/div/class функциональную переменную а.
let b = a.cloneNode(true) - копирование элемента из вёрстки (true) чтобы клонировать весь код элемента(в глубину), а не только оболочку.
a.remove(); удалить а.
простая функция: 
function(elem, i, mass) {} 
стрелочная функция:
(elem, i, mass) => {}
применяется не всегда чё-то там связанно с .this
для примера взят форич в котором желательно указать три аргумента имя итерируемого elem элемента имя переменной i имя массива mass // берутся из головы


