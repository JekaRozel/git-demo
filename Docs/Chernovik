sysstat	/ mpstat | grep -A 5 "%idle" | tail -n 1 | awk -F " " '{print 100 - $ 12}'a

<img src="{...}"> в кавычках твои данные
linux neofetch 	miral-shell
для облегчения elementary: 
создал файл 
/etc/environment:
CLUTTER_PAINT=disable-clipped-redraws:disable-culling
CLUTTER_VBLANK=none

sudo apt install software-properties-common python-software-properties установка ppa репозиториев
sudo cat /proc/sys/vm/swappiness размер файла swap
https://www.udemy.com/ru/topic/java/free/
выполнить файл(установка идеи) ./idea.sh
lsof список процессов запущенных приложением
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64

wiki.jetbrains.net/intellij/Creating_and_importing_Maven_projects

127.0.0.1
80 - стантдартный порт для HTTP запросов
apt (для дебиан) - yum
классификация gTLD (generic Top-Level Domains), куда вошли домены .com, .edu, .net, .org, .int, .gov и .mil. 

 feature branches (изолированная работа каждого разработчика над своей задачей)

ﬂoat работает с числами со значениями (по модулю) до 3,4×1038. Чувствительность переменной (минимальный шаг дискретности)  3,4×10-38. Точность значений до 8 цифр в представлении числа. Максимальное значение и минимальный шаг дискретности для double соответственно 1,7×10308 и 1,7×10-308. Точность в представлении числа 17 цифр. double намного предпочтительней.

Рекурсия - в коде описания метода вызывается этот же метод (но с другим аргументом). 
int F(int n){  if(n==1) return 1;  else return n*F(n-1);}

x.toString(), Integer.toString(x); ""+x;
String.valueOf(x); Integer.valueOf(x);
int a = Integer.parseInt(str);
String.join(" ", words)//массив words через пробел в строку.
char []c = str.toCharArray();

	Из видоса по Java EE, который я не досмотрел.
.POM файл инструкция для maven
Spring со старта сам создал веб-приложение, которое содержит tomcat, servlet(описал и сконфигурировал его) его же развернул в tomcat и сконфигурировал tomcat 
	/* tomcat- Java-приложение, которое заботится об открытии порта для взаимодействия с клиентом, настройке сессий, количестве запросов, длине заголовка и т.д. его компоненты:
Catalina - контейнер сервлетов, реализует Servlet API(хотя так называют томкат)
Jasper - позволяет использовть JSP, что является HTML-файлом со встроеным Java-кодом. Превращает Java в HTML и работает с ним.
Coyote - реализует функцию HTTP-сервера. */

Static Binding - раннее связывание, в момент компиляции. 
Dynamic Binding - позднее связывание, в момент выполнения программы.
 система логирования в JAVA.

	Tренинг епама.
классы и пакеты называют только в единственном числе
пакет: зеркальное.доменноеИмя.имяПакета.названиеПроекта.пакетыПриолжения;
by.tut.news; рекомендуется не больше 8-и уровней вложенности.
название_в_пакете_разделяется_подчёркиванием.
имя переменной - идентификатор (в имени можно использовать только $ и _ даже на первой позиции) (но $ в начале ставит jasper)
размерности boolean/void -, byte 8, char/short 16, int/float 32, double/long 64. Неявное приведение типов от по возрастанию (исключения 2: long -> double/float тоже неявное; char неявно только к int хотя 16 к 32)
арифметика не ниже 32, все арифметические операнды выражения приводятся к int либо чему-то(если присутствует в выражение) большему(long/float/double).
char a; int b; += приведёт к int. a += b + 2; -> a = (int) (a + (b+2)); неявное явное приведение типов.
Math.pow(3,6) -> 3 в 6-ой. Math.sqrt(4) квадратный корень.
Math.abs(-6) по модулю.
StrictMath - для точности при операциях с вещественными типами(float/double) как я понял с 1.6 вызывается через Math и можно не заморачиваться.
библиотеки лучше смотреть в документации oracle. (docs/api/)  
BufferedReader-символьное чтение.
dataInputStream-байтовое чтение (читаем сразу примитивные типы).
Точка вызова метода. Метод может иметь много входных значений, но только одно выходное. 
Шилдт - нет! грязный код в примерах.
scanner не надо закрывать если ввод с консоли, надо если из файла, то тольок в блоке finally (try catch) 


============================================ВАЖНО=====================================================================================
	Немчинский необходимые софтскилы.
 Английский
 Общение
 Estimations - оценка времени выполнения работы(задания)\
 быть осторожными с обещаниями
 признавать ошибки


    Теория из видосов немчинского.
Путаница версий java: 1; java 2 - java 2(1.4); 5(java2 (1.5)); 6(java 2 (1.6))...
cms content menegment systems (системы управления контентом) WorldPress Joomla
для микросервисов используют spring.
	парадигма - способ мышления (восприятия).
компиляция - превращени исходного кода в машинный кода / компайл тайм - процесс превращения исходного кода в бинарный (javac поиск зависимостей библиотек) \ ран тайм
API application programming interface - то через что работают с объектом должно быть public (остальное private). Этим определяется уровень доступа (инкапсуляции). Static - значит что это общий (метод/поле) для всех обектов этого класса. То что не Static относится к конкретному эеземпляру объекта. (лучеше не использовать).
JDBC (java data base connectivity) драйвер для баз данных.
JPA java persistans architect 
не стоит тратить сейчас время на Swing/SWT и FX (для ui). Отдать пердпочтение веб интерфейсу и спрингу.
JSP java server pages (для веба)
Доменная модель. начинаем писать приложение с "декомпозиции предметной области" - выписываем все объекты которые будут задействованы определяем их свойства. дальше бизнес логика(логика взаимодействий между объектами), DAO (data access logic) работа с базой данных, UI слой. Это интерпрайз паттерн domain model.   	
---------
	
Раннее связывание - мы знаем или передаём известное значение Shape a = new Circle(20)
Позднее - мы узнаем после компиляции int res = circle.square();
 класс наследник не обязан реализовывать все методы родителя? а наследник интерфейса(от интерфейса) должен реализовывать все методы родителя и так же деда, прадеда, ...
 Класс может содержать 4 виды внутреннийх классов: 
-внутренний каласс;
-локальный внутренний класс; (находится внутри метода)(метод возвращающий объект класса - фабричный метод) (может быть безымянным, 
-статический внутренний класс; (имеет доступ только к статическим полям и методам внешнего класса).
 Многопоточность. Класс thread Runnable
 java.io. - файловые потоки ввода-вывода.
 str.split(" ")
 Рефлексия java.lang.reflect. Constructor/Field/Method/Modifier (всё через массив).
 сериализация (обязательно - implements Serializable) разбивка на байты для передачи. десериализация - сборка из байтов. 
-анонимный внутренний класс;.
  Generic - контейнеры, коллекции. Доступ: прямой и последовательный. (java.util....)
Set не может хранить одинаковые значения. Разница между hash/tree/list set в варианте хранения (последовательности/упорядоченности) элементов. 
 list offer статвит элемент в очередь. poll получаем и удаляем из очереди, peek получаем не удаляя.
 Vector
 Stack последний зашёл - первый вышел.
 map (key + value) : hashTable, LinkedHashMap, TreeMap. Entry<obj : obj> entry : map.entrySet() - для перебора.

Как переопределять метод equals в Java
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/
if (obj == this) {
/*и верните */ return true;}
   модификатор static применяется для создания методов и переменных класса;
модификатор final используется для завершения реализации классов, методов и переменных;
модификатор abstract необходим для создания абстрактных классов и методов;
модификаторы synchronized и volatile используются в Java для потоков

Static 
-вызывпется без создания объекта класса: имяКласса.имяСтатикМетода();
-статические методы нельзя переопределить;
-статические объекы могут ссылаться только на статические переменные
-статические методы/переменные общие дял всех эеземпляров класса.

int num = sc.nextInt(); (если инициализируем не константой, то надо разделять объявление и присвоение.) int num;   num = sc.nextInt();
stack(thread) memory, heap, permanent (размеры этих объектов можно поменять в настройках виртуальной машины)
в heap (куча) (создаются и хранятся объекты, орудует сборщик)
структура данных stack(thread) реализует правило LIFO
frame кусочек памяти выделяемый под выполнение. В нём хранится адрес возврата в стек (return), байткод выполняемого метода, здесь же выделяется память под локальные переменные метода.
пул литералов



Из курсов "Изучаем Java"
У объкета методы - поведение, поля - состояние.
не явное приведение типов работает когда не теряются данные.
явное приведение - если обрезаем 		
Имя pubclic класса должно совпадать с именем файла. Public класс может быть только один. Только паблик классы видны в других пакетах.
Поля должны быть private (если не final)
Имя класса - существительное. Интерфейса - прилагательное.
Класс может быть только либо без модификатора доступа, либо public. Другие модификаторы: 
strctfp (strictFloatinPoint) можно определять точность вычисления float переменных во всех методах.
abstract - нельзя создать экземпляр. (a. метод может быть только в а. классе, но в а. классе може т не быть а. методов) а. метод не содержит тела(нет {...} сразу ; // abstract void method();) наследники а. класса обязаны переопределить все а.методы. а. класс может наследоваться от обычных методов, просто следует знать.
final - нельзя наследовать или менять.
либо abstract либо final.
Интерфейс используется для описания поведения. Они полностью abstract но указывать это ключевое слово не надо, оно и так подразумевается. методы - puclic abstract, поля - final. Интерфейсы implements а не extends, поэтому их может быть много у одного класса.

	модификаторы доступа для методов
private - только в этом классе
protected - только в этом классе и наследниках мы можем её менять !!!! проверить что от он как и default виден на уровне пакета. 
default - в других классах всого package
public - везде 																																																														
	модификаторы переменных
private protected default public
и ещё в дополнение: 
final (делает неизменным, константа. Можно задать значение напрямую или конструкторе) 
static (одно значение на все классы, возможность получать доступ без создания объекта, можно менять значение) 
transient(убирает поле из сериализации, процесса разбиение на байты для передачи данных) 
volotile(многопоточность, переменную читать из памяти, а не кэшированую версию. Обычно используется когда один поток пишет, а остальные читают) 
 поля инициализируются по-умолчанию, а переменны в методах(локальные) надо вручуню. Поля и локальные могут иметь одинаковое имя и не мешать друг другу(shadowing, перекрытие).
параметры хранятся в стэке(быстрый доступ) (хип выделяется под)
 
	модификаторы метода
void (либо тип возвращаемого значения (return))
final (не измеянется, нельзя переопределить)
static (используется без создания экземпляна класса, не может содержать не static поля)
abstract (без тела, не бывает final/static, должен переопределяться в наследниках)
synchronized (может выполняться только в одном потоке)
strictfp (точность float, редкий)
native (методы реализованные на других языках. сами не используем, можем встретить) 
в параметрах varargs... должен быть только один и последним в списке
 
	Конструктор
 Метод у которого из сигнатуры есть модификаторы доступа и имя совпадает с именем класса, параметры. Используется для инициализации. Можно переопределять сколько угодно с разными параметрами и телами.
 Создаётся по-умолчанию c модификатором доступа как и класса, без параметров и телом: {supe();}. Если мы определили хоть один, то по-умолчанию уже не создаётся. В теле supe(); добалвяется постоянно и неявно(не видно). Благодаря этому в первую очередь вызывается конструктор родителя и по нисходящей. 

	Enum (перчисление)
enum name {first, second, ...} // можно без ";"
можно определять в классе, вне класса(public/default), но только не в методе
по сути, это краткая запись класса хранящего final поля.
может содержать в себе поля, методы и конструкторы:
 enum name {first(f), second(f);
  int f;
  name(int f){ this.f = f;}
 }
метод можно переопределить для отдельного значения в перечислении.
enum name {first(f), second(f), third(f) {
  String method(){
	return otherMethod; }
 };
   Sting method(){
	return oneMethod;}
}

	Overload перегрузка методов
 Метод с одинаковым ИМЕНЕМ но разными сигнатурами: модификаторами доступа, модификаторами метода, возвращаемыми типами, принимаемыми параметрами, эксепшенами. Т.е. метод который может принимать разные значения. 
 Метод с одинаковым именем находящийся в наследном классе тоже явяется перегуженным, хоть и кажется что он переопределён.
 Последовательность приоритета преобразований short(из типов котороые могут встретиться):
short int long double float Short(wrapper) Object short...(massive)(1) автоприведение к примитивам, 2) обёртка(автобоксинг), Object,3) массив).

	Overriding переопределение методов
 У переопределённых методов могут быть разные:
модификаторы доступа, но только при условии что насленик расширяет видимость. 
модификаторы метода.
exceptions опять же при условии что у наслендика exception будет наследником родительского exctption.

static вообще нет смысла использовать. 
тип возвращающего значения должен быть одинаковым, либо соответствовать иерархии (родитель-наследник будут приняты как одинаковый тип).
// Parent a = new Parent(); Parent b = new Child(); разобрать почему так.

	STATIC
 Статическими могут быть поля, методы, инициализаторы(код в конце, не сработавший у меня) 
Статические поля и методы нужны чтобы иметь некоторые переменные на уровне экземпляра класса.
Статическая переменная создаётся при первом обращении к классу. Статический метод можно создавать

	блоки инициализации (не работающие у меня)
static { code } и обычный{ code }. Их может быть много и вызываются они по порядку 
Выполняются: static { code } при первом обращении к классу, обычный { code } при каждом вызове конструктора класса( вызывается сразу после super(); )  
 
 	
Двумерный массив можно указать так:
int[n][] i; или так int[n] i[]; или так int i[n][]  

	Wrappers
 Cсылочные типы хранят ссылки на объект в heap, String хранятся в пуле стрингов. Для сравнения используется equals(сравненти внутренних значений)
 int a = new Integer("4"); wrapper Integer распарсит строку и сохранит целочисленное значение в int.
Три самых частые методы 
int a = Integer.parseInt(" 4"); возвращает int
Integer b = a.valueOf("4"); возвращает Integer
short s = a.shortValue();  возвращает требуемый примитив.
 Автоупаковка - при действиях над обёрткой происходит автоматическое преобразование к примитиву
, действие над примитивом, обратное преобразование к обёртке.

 	Garbadge Collector
 Object ob = new Object(); Создаём ссылку ob и создаём новый объект посредством new и записываем ссылку на этот объектв ссылку ob.
 Мусорщик постоянно ищет ссылки на объекты. Когда находит объект без ссылок(на этот объект).
 Ссылка которой присвоили значение null - кандидат на удаление мусощиком
 Вызов мусорщика System.gc(); никогда не используется но знать надо что послевызова System.gc() мусорщик может либо запуститься, либо не запуститься ( на своё усмотрение). Запуск System.gc() вызыветм метод объекта finalize();, который есть у всех методов(наследство от Object)

 	Операторы
 a == a1 сравнение примитивов
 а.equals(a1) сравнение ссылочных типов (объектов)
 а.instanceOf(a1) является ли объект а наследником а1

из консоли запуск java Main param1 param2 прямая передача параметров(args) в метод main(String[] args) 




















































 класс должен запускаться без main класса /попробовать в идее
class WithoutMain {static {System.out.println("Start without Main method");System.exit(0);}}
попробовал - не работает.


