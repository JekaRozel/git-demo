sysstat	/ mpstat | grep -A 5 "%idle" | tail -n 1 | awk -F " " '{print 100 - $ 12}'a

<img src="{...}"> в кавычках твои данные
linux neofetch 	miral-shell
для облегчения elementary: 
создал файл 
/etc/environment:
CLUTTER_PAINT=disable-clipped-redraws:disable-culling
CLUTTER_VBLANK=none

sudo apt install software-properties-common python-software-properties установка ppa репозиториев
sudo cat /proc/sys/vm/swappiness размер файла swap
https://www.udemy.com/ru/topic/java/free/
выполнить файл(установка идеи) ./idea.sh
lsof список процессов запущенных приложением
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64

wiki.jetbrains.net/intellij/Creating_and_importing_Maven_projects

127.0.0.1
80 - стантдартный порт для HTTP запросов
apt (для дебиан) - yum
классификация gTLD (generic Top-Level Domains), куда вошли домены .com, .edu, .net, .org, .int, .gov и .mil. 

 feature branches (изолированная работа каждого разработчика над своей задачей)

ﬂoat работает с числами со значениями (по модулю) до 3,4×1038. Чувствительность переменной (минимальный шаг дискретности)  3,4×10-38. Точность значений до 8 цифр в представлении числа. Максимальное значение и минимальный шаг дискретности для double соответственно 1,7×10308 и 1,7×10-308. Точность в представлении числа 17 цифр. double намного предпочтительней.

Рекурсия - в коде описания метода вызывается этот же метод (но с другим аргументом). 
int F(int n){  if(n==1) return 1;  else return n*F(n-1);}

x.toString(), Integer.toString(x); ""+x;
String.valueOf(x); Integer.valueOf(x);
int a = Integer.parseInt(str);
String.join(" ", words)//массив words через пробел в строку.
char []c = str.toCharArray();

	Из видоса по Java EE, который я не досмотрел.
.POM файл инструкция для maven
Spring со старта сам создал веб-приложение, которое содержит tomcat, servlet(описал и сконфигурировал его) его же развернул в tomcat и сконфигурировал tomcat 
	/* tomcat- Java-приложение, которое заботится об открытии порта для взаимодействия с клиентом, настройке сессий, количестве запросов, длине заголовка и т.д. его компоненты:
Catalina - контейнер сервлетов, реализует Servlet API(хотя так называют томкат)
Jasper - позволяет использовть JSP, что является HTML-файлом со встроеным Java-кодом. Превращает Java в HTML и работает с ним.
Coyote - реализует функцию HTTP-сервера. */

Static Binding - раннее связывание, в момент компиляции. 
Dynamic Binding - позднее связывание, в момент выполнения программы.
 система логирования в JAVA.
	Tренинг епама.
классы и пакеты называют только в единственном числе
пакет: зеркальное.доменноеИмя.имяПакета.названиеПроекта.пакетыПриолжения;
by.tut.news; рекомендуется не больше 8-и уровней вложенности.
название_в_пакете_разделяется_подчёркиванием.
имя переменной - идентификатор (в имени можно использовать только $ и _ даже на первой позиции) (но $ в начале ставит jasper)
размерности boolean/void -, byte 8, char/short 16, int/float 32, double/long 64. Неявное приведение типов от по возрастанию (исключения 2: long -> double/float тоже неявное; char неявно только к int хотя 16 к 32)
арифметика не ниже 32, все арифметические операнды выражения приводятся к int либо чему-то(если присутствует в выражение) большему(long/float/double).
char a; int b; += приведёт к int. a += b + 2; -> a = (int) (a + (b+2)); неявное явное приведение типов.
Math.pow(3,6) -> 3 в 6-ой. Math.sqrt(4) квадратный корень.
Math.abs(-6) по модулю.
StrictMath - для точности при операциях с вещественными типами(float/double) как я понял с 1.6 вызывается через Math и можно не заморачиваться.
библиотеки лучше смотреть в документации oracle. (docs/api/)  
BufferedReader-символьное чтение.
dataInputStream-байтовое чтение (читаем сразу примитивные типы).
Точка вызова метода. Метод может иметь много входных значений, но только одно выходное. 
Шилдт - нет! грязный код в примерах.
scanner не надо закрывать если ввод с консоли, надо если из файла, то тольок в блоке finally (try catch) 


============================================ВАЖНО=====================================================================================

    Теория из видосов немчинского.
Путаница версий java: 1; java 2 - java 2(1.4); 5(java2 (1.5)); 6(java 2 (1.6))...
cms content menegment systems (системы управления контентом) WorldPress Joomla
для микросервисов используют spring.
	парадигма - способ мышления (восприятия).
компиляция - превращени исходного кода в машинный кода / компайл тайм - процесс превращения исходного кода в бинарный (javac поиск зависимостей библиотек) \ ран тайм
API application programming interface - то через что работают с объектом должно быть public (остальное private). Этим определяется уровень доступа (инкапсуляции). Static - значит что это общий (метод/поле) для всех обектов этого класса. То что не Static относится к конкретному эеземпляру объекта. (лучеше не использовать).
JDBC (java data base connectivity) драйвер для баз данных.
JPA java persistans architect 
не стоит тратить сейчас время на Swing/SWT и FX (для ui). Отдать пердпочтение веб интерфейсу и спрингу.
JSP java server pages (для веба)
Доменная модель. начинаем писать приложение с "декомпозиции предметной области" - выписываем все объекты которые будут задействованы определяем их свойства. дальше бизнес логика(логика взаимодействий между объектами), DAO (data access logic) работа с базой данных, UI слой. Это интерпрайз паттерн domain model.   	
---------
	
Раннее связывание - мы знаем или передаём известное значение Shape a = new Circle(20)
Позднее - мы узнаем после компиляции int res = circle.square();
 класс наследник не обязан реализовывать все методы родителя? а наследник интерфейса(от интерфейса) должен реализовывать все методы родителя и так же деда, прадеда, ...
 Класс может содержать 4 виды внутреннийх классов: 
-внутренний каласс;
-локальный внутренний класс; (находится внутри метода)(метод возвращающий объект класса - фабричный метод) (может быть безымянным, 
-статический внутренний класс; (имеет доступ только к статическим полям и методам внешнего класса).
 Многопоточность. Класс thread Runnable
 java.io. - файловые потоки ввода-вывода.
 str.split(" ")
 Рефлексия java.lang.reflect. Constructor/Field/Method/Modifier (всё через массив).
 сериализация (обязательно - implements Serializable) разбивка на байты для передачи. десериализация - сборка из байтов. 
-анонимный внутренний класс;.
  Generic - контейнеры, коллекции. Доступ: прямой и последовательный. (java.util....)
Set не может хранить одинаковые значения. Разница между hash/tree/list set в варианте хранения (последовательности/упорядоченности) элементов. 
 list offer статвит элемент в очередь. poll получаем и удаляем из очереди, peek получаем не удаляя.
 Vector
 Stack последний зашёл - первый вышел.
 map (key + value) : hashTable, LinkedHashMap, TreeMap. Entry<obj : obj> entry : map.entrySet() - для перебора.

Как переопределять метод equals в Java
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/
if (obj == this) {
/*и верните */ return true;}
   модификатор static применяется для создания методов и переменных класса;
модификатор final используется для завершения реализации классов, методов и переменных;
модификатор abstract необходим для создания абстрактных классов и методов;
модификаторы synchronized и volatile используются в Java для потоков

Static 
-вызывпется без создания объекта класса: имяКласса.имяСтатикМетода();
-статические методы нельзя переопределить;
-статические объекы могут ссылаться только на статические переменные
-статические методы/переменные общие дял всех эеземпляров класса.

int num = sc.nextInt(); (если инициализируем не константой, то надо разделять объявление и присвоение.) int num;   num = sc.nextInt();
stack(thread) memory, heap, permanent (размеры этих объектов можно поменять в настройках виртуальной машины)
в heap (куча) (создаются и хранятся объекты, орудует сборщик)
структура данных stack(thread) реализует правило LIFO
frame кусочек памяти выделяемый под выполнение. В нём хранится адрес возврата в стек (return), байткод выполняемого метода, здесь же выделяется память под локальные переменные метода.
пул литералов






`			STEPIK JAVA COLLECTONS
	Особенности коллекций:
-динамическая изменяемость.
-не работают с примитивами.
Есть два коренных родительских интерфейса(оба дженерики):
java.util.Collection<E>
java.util.Map<K, V>

List подразумевает обращение по индексу как массив
Set хранит в случайном порядке уникалные(без повторов) элементы
Queue FIFIO
Stack LIFO
Deque FIFO одновременно с LIFO 
Map ключ - значение.
	Иерархия интерфейсов
Collection
-List
-Set --SortedSet
-Queue --Deque
Map
-SortedMap
Collection и Map не наследуют друг друга, это два независимых корневых интерфейса
Stack не используется, вместо него рекомендуют Deque
Основные методы коллекций List<E>, Set<E>, Queue<E> унаследованные от родителя Collection<E>
int size()
boolean isEmpty()
boolean contains(Object o)
boolean add(E e)		???
boolean remove(Object o)
void clear()

Map - не коллекции, но часто рассматриваются как таковые
	методы
int size()
boolean isEmpyt()
boolean containsKey(Object key)
boolean containsValue(Object value)
V get(Object key)
V put(K key, V value)
V remove(Object key)
void clear()
Set<K> keySet()
Collecton<V> values()
Set<Map.Entry<K, V>> entrySet()

		ТЕПЕРЬ ПОДРОБНЕЕ КАЖДУЮ. LIST
	Методы интерфейса List<E>
унаследованные
int size()
boolean isEmpty()
boolean contains(Object o)
boolean add(E e)		???
boolean remove(Object o)
void clear()
+ новые
E get(int index)
void add(int index, E element)
E remove(int index)
E set(int index, E element)
int indexOf(Object o)
  
 Нельзя создать объект List, но можно создать объект его наследников: ArrayList & LinkedList. Их различия в механизме ввода элементов. Но общий родитель (унаследованные методы) позволяют использовать их одинаково.
 У ArrayList - автоматически расширяемый массив. Может быть любого (даже null) типа.
У него есть три перегурженных метода
ArrayList() по-умолчанию размерность 10,  A																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																											rayList(Collection<? extends E> c), ArrayList(int initialCapacity) 
 У LinkedList есть два пергруженных метода:
LinkedList(), LinkedList(Collection<? extends E> c)
 Полезные операции.
 for (String name : ArrayList/LinkedList) {
 System.out.println(name); }
 Object[] objArray = ArrayList/LinkedList.toArray(); /преобразование list в массив объектов
 Srting[] strArray = ArrayList/LinkedList.toArray(new String[0]); /преобразование list в массив строк
 List<String> list = java.util.Arrays. asList("one", "two", "three"); преборазование массива в list
 ArrayList/LinkedList.subList(a, b);  кусок списка где: a- с какого элемента включительно, b- до какого не влючая.

		Queue
First In First Out. Доступны только две операции. Можно добавлять новые в конец очереди enqueue и удалять имеющиеся из начала очереди dequeue.
Наследуется от Collection.
	Методы
boolean add(E e) вставляет элемент если возможно, возвращает тру или exception
boolean offer(E e) просто вставляет элемент если возможно
E remove() возвращает и удаляет элемент из головы очереди, exception если пусто
E poll() возвращает и удаляет элемент из головы очереди, null если пусто 
E element() возвращает но НЕ удаляет элемент из головы очереди, exception если пусто
E peek() возвращает но НЕ удаляет элемент из головы очереди, null если пусто 

		Stack
Last In First Out.  Доступны только две операции. Добавить элемент в конец очереди push и удалить элемент из конца же pop
Но его не рекомендую использовать. Предпочтение следует отдавать двусвязному Deque
	Методы
.push(E e) добавляет 
.pop() удаляет
		Deque
java.util.Deque<E> extends (расширяет) java.util.Queue<E>. По сути это двусвязный список и он позволяет как FIFO так и LIFO (работать с обоими краями очереди). Есть два варианта реализации этого интерфейса ArrayDeque и LinkedList. Следовательно эти два класса могут применятся как Queue (FIFO), Stack (LIFO), and Deque (Double-Ended Queue)
	Методы
 Работа с началом очереди
addFirst(e) добавить если не может то бросает exception
offersFirst(e) добавить если не может то возвращает какое-то значение
removeFirst() удалить если не может то бросает exception 
pollFirst() удалить если не может то возвращает какое-то значение
getFirst() посмотреть элемент если не может то бросает exception 
peedFirst() посмотреть если не может то возвращает какое-то значение
 
 Работа с концом очереди
addLast(e)  добавить если не может то бросает exception
offerLast(e) добавить если не может то возвращает какое-то значение
removeLast() удалить если не может то бросает exception
pollLast() удалить если не может то возвращает какое-то значение
getLast() посмотреть элемент если не может то бросает exception
peekLast() посмотреть если не может то возвращает какое-то значение
 
 





































