Рекомендации для себя:
Посмотреть UML модели.
Значения по умолчанию: false, '\u0000'(null) остальные 0.
Значеня по умолчанию гарантируются только если переменная используется как член класса (не локальная переменная).
printb();печать в текущей строке, printf(format, args). разобрать

		Теория.
  Все ЯП построены на абстракции.
  Академический, "чистый" подход к ООП:
* Всё является объектом.
* Программа - это группа объектов, указывающих друг другу, что делать, постредством сообщений.
* Каждый объект имеет собственную "память", состоящую из других объектов.
* У каждого объекта есть тип.
* Все объекты определённого типа могут получать одинаковые сообщения.
 Коротко: Объект обладает состоянием, поведением и индивидуальностью. Взаимозаменяемось - мощнейшее понятие ООП.
//Объект=экземпляр, класс=тип, манипулировать_объектом=посылать_сообщение=делать_запрос.
  Каждый объект принадлежит к определённому классу, который опредеяет его характеристики и поведение. Класс является типом данных, равноценным встроенным типам. Создав новый класс можно создавать сколько угодно обектов этого класса, манипулируя ими как элементами решаемой задачи. 
  Одна из основных трудностей ООП - установление однозначного соответствия между объектами "пространства задачи" и объектами "пространства решения". 
 Запросы которые можно посылать объекту, определяются его интерфейсом, а он определяется типом. \Объект.метод()\ - запрос.
 Задача - произвести (или найти в библиотеке) набор объектов, оптимальный для решения конеретной задачи.
 Важна связуемость(cohesiveness) объекта(метода, и т.д.) Основная ошибка - перенасыщение свойствами и возможностями). Объект должен справляться с одной конкретной задачей, не пытаясь сделать лишнего.
  Скрытая реализация: П.создатель далжен построить класс, скрывающий всё и открывающий только то, что нужно П.клиенту. П.клиент должен собрать больше нужных классов и заниматься быстрой разработкой программы. Причины необходимости скрытой реализации:
- уберечь "хрупкие" детали от П.клиента.
- П.создатель может изменять внутренние механизмы класса не влияя на работу П.клиента.
 Спецификаторы доступа:
 public доступен всем (для конечного пользователя)
 private доступен только создателю типа, внутри его методов. (privat+геттеры/сеттеры = инкапсуляция)
 protected  доступен только создателю типа внутри его методов и его производным классам, которые получают доступ к protected, но не к private.
 default (package access/visible) по-умолчанию (отсутствие) в пределах пакета, за его пределами становятся private.
  Повторное/многократное использование кода. Можно просто создавать его(существующего класса) объект. Можно внедрить объект внуть нового класса (неограниченное кол-во разных объектов в любом сочетании). Составление нового класса из уже существующих - Композиция (связь типа "имеет" has-a). Агрегация - динамическая композиция. 
  Наследование. Взять готовый класс, клонировать его и внести добавления и обновления в полученный клон. Только если начальный/базовый/суперкласс/родительский класс то изменения касаются его клона/производный/унаследованный/подкласс/дочерний класса. Базовый тип содержит все характеристики и действия, общие для всех производных от него типов. Производные же типы могут иметь(или не иметь) дополнительныйе характеристики. Базовый тип - основа порождающая другие типы, выражающие другие реализации этой сущности. Производный класс является частным случаем базового класса, повторяет интерфейс и может обрабатывать те же запросы что и родитель.
 Способы изменения: 
1 добавление методов.
2 переопределение - изменение поведения имеющихся методов базового класса.
 При полном переопределении и не добавлении новых методв - связь называют "является тем-то", "принцип замены", объект родитель можно легко заменить дочерни объектом. //считают лучше
 При добавлении методов происходит расширение, теперь замена классов не совсем подходит (новые методы из дочернего нельзя применить в родительском объекте).
  Позднее связывание использут ООП-компиляторы, Ранне связывание - не ООП-компиляторы (в этих ЯП методы по умолчанию компонутся не динамчески). 
  Расширяемая программа, это та которя работает для добавленного посредством наследования нового типа, также хорошо, как и прежде.
  Восходящее преобразование типов - принадлежность к другому типу, выше по иерархии. 
  Полиморфизм(условно) - при вызове общего для разных объектов метода, выполняется тот, что нужен для конкретного объекта.
  Object - родитель всех классов. Это однокорневая иерархия.
  Контейнеры используют когда не известно сколько будет объектов и сколько они просуществуют. Они находятся в стандартной библиотеке. Это: List(списки для последовательностей), Map(ассоциативные массивы, карты связывающие объекты с другими объектами), Set(множества обеспечивающие уникальность значений для каждого типа). Контейнерные библиотеки так же могут содержать очереди, ыеревья, стеки и т.п..
  Параметризованные типы(generics) - классы, которые компилятор может автоматически адаптировать для работы с определёнными типами. Используют нисходящее преобразование типов. Указываются контейнерам < >.
  В Java используется только динамическое создание объектов в "куче". Создание происходит по мере необходимости, во время исполнения программы, а удаление "сборщиком мусора". Гораздо дольше чем размещение объектов сразу в стек(область статического хранилища), чем достигается максимальная скорость исполнения программы. Но надо знать количество и время жизни объектов.
  Механизм обработки исключений встраивает обработку ошибок прямо в ЯП. Исключение представляет собой объект, геренируемый на месте возникновения ошибки, который потом может быть перехвачен подходящим обработчиком исключений. "Параллельный путь" когда что-то не так. Если не обработать, то выдаст ошибку(выкинет).
  Параллельное выполнение разынх частей программы(потоков) - многозадачнось/параллельные вычислений. Пример GUI - нажал кнопку - получил ответ. На однопроцессорном - распределяют схему распределения времени, на многоядерных - распределяют по ядрам, кол-во ядер определяется автоматически. Подвох в том, что один ресурс не может работать сразу с несколькими потоками.
  Клиент/сервер пропущу.
  Отправленная форма обрабатывается интерфейсом CGI для всех серверов. Текст запроса указывает CGI как именно поступить с данными.
  Апплет - мини-программа, исполняющаяся внутри браузера.

		ГЛАВА 2.
	ВСЁ ЯВЛЯЕТСЯ ОБЪЕКТОМ.
  Только неинициализированные объекты - ссылки, которые никуда не ведут. Настоятельно рекомендуется сразу инициализировать объекты (связывать ссылки с объектами через new)
String str = new String('abc'); это предоставление нового объекта String и указывает как создать строку посредством передачи началльного набора символов.
  Места хранения данных в памяти:
1 Регистры. В процессоре, быстрое, мало места, мы не лезем.
2 Стек. Общая оперативная память (RAM) но процессор предоставляет прямой доступ к ней с использованием указателя стека. Медленней Регистров т.к. компилятор должен знать жизненный цикл данных, размещаемых в стеке. Сами объекты в стек не помещаются.
3 Куча. в RAM пул памяти общего назначения, в котором размещаются все объекты Java. Память под объект выделяется во время выполнения программы по запросу new. Это не быстро.
4 Постоянное хранилище. константы. иногда в ROM.
5 Внешнее хранилище. Либо вне программы: streamed objects как поток байтов(обычно для передачи на другие машины. Либо долгоиживущие объекты persistent(на диске или носителе). 
 Примитивные типы не используют new а автоматом саздают переменную не являющуюся ссылкой. Чтобы размещаться в стеке, для скорости работы. Эти типы: boolean0, char16, byte8, short16, int32, long64, float32, double64, void0. Чтобы испоьлзовать их как ссылочные типы есть классы-обёртки. BigInteger/BigDecimal классы-обёртки не имеющие примитивных аналогов, работают с числами/значениями_после_запятой повышенной точности (вроде очень большие).
 При объявлении массива объектов на самом деле создаётся массив ссылок (на null, т.е. не указывает на объект), при примитивах нули.
 Scope - область действия (видимость и срок жизни имён) ограничивается {}. Scope действует так же и на ссылки на объекты (а вот сами объекты потом убирает мусорщик)
  Тип. Указание типа: class type name(); type a = new type();
  Поля и методы. 
 Поля(переменные класса) - объекты любого(ссылочного) или примитивного типа (ссылку необходимо инициализировать через new). Для каждого объекта свой блок памяти. ссылка.поле
 Методы(функции класса). Определяют сообщения принимаемые объектом. Состоит: возвращаемый тип, имя, аргумент, тело. Сигнатура - имя+аргументы. Отправка сообщения объекту: int x = имяОбъекта.имяМетода(агрументы) (тип переменной должен совпадать с возвращаемым типом).
 Аргументы("тип имя") список определяющий какая информация передаётся методу.
 ключевое слово return - "выйти из метода, всё сделано" вернуть значение следующее за return.
 выходной тип void (завершить метод ничего не возвращая). return нужен, но опускается.
 Язык сам предотвращает конфликты имён. Для создания уникальных имён используется перевёрнутое доменное имя с перечнем каталогов разделённом точками.
 Ключевое слово import командует загрузить пакет(package), предстовляющий собой библиотеку классов. import java.util.*;
 Ключевое слово static используется: 
1 когда данные в единственном числе, при любом количестве создаваемых объектов. К объекту рекомендуется обращаться через имя класса (ИмяКлассаГдеРасположена.СтатическаяПеременная). 
2 когда метод долже вызываться без объекта(не быть привязан к конкретному объекту класса).
 Статические данные существуют на уровне класса. Не статические на уровне объектов.
  УПРАЖНЕНИЯ СТР.94

			ГЛАВА 3.
		     ОПЕРАТОРЫ.
 Integer.toBinaryString()/Long.toBinaryString() двоичное представление.
1.39е-43f значит 1,39*10в-43степени (это для float)
Поразрядные операторы & | ^ ~ (и или xor(исключающее или) не(двоичного дополнения))
а<<2 a сдвигается влево на 2 бита (тоже для >>). При +2 пустые биты заполняются 0-ми, при -2 1-ми. >>> заполняет 0-ми не зависимо от знака. Если сдвигается char, byte, short то они приводятся к int и в результате будет int. >>= сокращённое присваивание (как и +=)
При неявном приведении меньший тип приводится к большему.
Для округлинеия Math.random()
  
			ГЛАВА 4.
		УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ.
foreach перебор массива:
for(int i : mass) 
Для перебора символов строки:
for(char c : "Some string".toCharArray());
не работает для перебора с ограничением (i<=100), только все элементы массива.
printb не выводит символы новой строки
break завершает цикл, всё что в цикле дальше не выполняется.
continue останавливает цикл и начинает следующий шаг этого же цикла.
Метки обычно используют перед циклом со вложенными циклами, чтобы continue или break вложенных циклов прервал всю цепь. mark: for(){for(){for(){break mark;}}};

			ГЛАВА 5.
		ИНИЦИАЛИЗАЦИЯ И ЗАВЕРШЕНИЕ.
  Это основные проблемы небезопасности. Инициализация гарантируестся конструктором. При наличии в методе он обязательно вызывается.
Имя конструктора должно являться именем класса. Конструктор без аргументов называется конструктором по-умолчанию. Только если других нет, то создаётся по-умолчанию.
Конструктор не возвращает ничего (return) и не имеет типа (даже void). Оператор new возвращает ссылку на вновь осзданный объект, но сами конструкторы не имеют выходного значения. 
Перегруженые методы отличаются только списком аргументов. Вызывает путаницу что в списке аргументов может происходить неявное приведение примитивных типов.
 Ключевое слово this используется для не-статических методов и предоставляет ссылку на объект, для которого был вызван метод, чтобы Явно сослаться на текущий объект. Так же применимо к конструкторам (для вызова одного из другого). //как-то так.
 Ключевое слово static. Статический можно вызвать из не-статического, но не наооборот. Можно вызвать без каких либо объектов.
 Ключевое слово finalize() позволяет выполнить завершающие действоия во время работы сборщика мусора. Явно указывает что надо убрать, например когда память под объект была выделена без new (Например рисунок не удалиться пока не сотрём). Используется для управления памятью используемой программой.
 При вызове локальной неинициализованной переменной - ошибка, но если вызываем метод с неинициализованной переменной(полем) - ей присваевается значение по умолчанию.
 ENUM перечисление. Удобно для Switch, встроены toString() обращаться по имени, ordinal() обозначение порядка объявления констант, values() возвращающий массив констатн enum в порядке их объявления.

			ГЛАВА 6.
		УПРАВЛЕНИЕ ДОСТУПОМ.
  Всё храниться в пакетах (package), одно пространство имён Рефакторинг. это (улучшение рабочего кода) можно проводить не мешая пользователю кода. Для этого используют спецификаторы доступа(acces specifiers), явно указывающие, что доступо пользователю кода, а что нет: 1 public, 2 protected, 3 (в пределах пакета), 4 private. Хранить всё надо секретно, открывать только те методы, которые можно использовать пользователю кода. 
 import для использования класса из другого пакета.
Компилируемый модуль - файл с исходным текстом на Java, имеющий суффикс .java. В нём может находиться public класс(не более одного), с тем же именем, что и у файла(с заглавной буквы но без суффикса .java). Остальные(если есть) классы - вспомогательные к главному открытому.
 Рабочая программа - набор файлов .class(результаты компиляции одноимённых классов, определённых в файле .java), которые объеденяются в пакет и сжимаются в файл JAR. A интерпретатор ищет, грузит, интерпретирует их. Библиотека - так же набор из одного public и любого кол-ва не public класоов. Package хранит вместе .java и .class связанные файлы. Указывается в первой незакоментированной строке.
 Можно использовать не import а имя класса полностью через точку.
  Первая часть имени пакета должна состоять из превернутого доменного имени разработчика класса. Имя пакета преборазуется в каталог на диске.
 Переменная окружения CLASSPATH содержит список из одного или нескольких каталогов, используемых в качестве корневы для .class. Интерпретатор заменяет точки на слеши(или нужные символы). Затем поученное имя присоединяется к различным элементнам CLASSPATH. И в указанных местах ведётся поиск файлов .class. CLASSPATH может содержать несколько альтернативных путей для поиска (один из них точка, для поиска в текущем каталоге). Для JAR файлов в CLASSPATH  необходимо полностью указывать путь.
 !Имя пакета - его Каталог!
 1 public Класс доступен для всех.
 3 в пределах пакета (по умолчанию). Находятся в одном каталоге и не задано явное имя пакета.
 4 private доступ закрыт для всех кроме СОБСТВЕННЫХ МЕТОДОВ (можно вызвать privateКласс.ОткрытыйМетод())
 5 protected Доступен в пределах пакета и наследникам.
  Сокрытие реализации - контроль над доступом. В комнбинации с помещением данных и методов в классы - это инкапсуляция.
 В файле может быть только один public класс(или его может вообще не быть).
 Методам следует давать тот же уровень доступа что и у класса (по умолчанию или public), а полям - private. Класс не может быть protected или private.

			ГЛАВА 7.
		ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ КЛАССОВ.
 Композиция - объект уже имеющегося класса создаётся внутри вашего нового класса. Используется функциональность готового кода, не структура.
 Наследование - новый класс создаётся как специализация уже существующего.
 Ссылку можно проинициализировать самостоятельно: 
- в точке определения конструктора(инициализация перед вызовом)
- в конструкторе данного класса
- перед использованием объекта(отложенная инициализация)
  Наследование extends используется всегда, если не указано, то от корневого класса Java Object.
- с использованием инициализации экземпляров.	
// метод main можно определять для в каждом из своих классов. Если класс не public, то чтобы вызвать его main надо обращаться НеPublicКласс.main(); Рекомендуется объявлять поля private, а методы public.
 В классе наследнике обращаемся к методу родителя: super.parentMethod(). Помимо родительских можно определять любые новые свои.
 Когда вы создаёте объект производного класса внутри него содержится подобъект базового класса. Словно родительский "упакован" в дочернем.
 Вызов конструктора базового класса автоматически вставляется в конструктор производного класса.
 При создании объекта класса-наследника в первую очередь инициализируются методы класса-родителя.
 Если класс не имеет конструктора по-умолчанию или надо вызвать конструктор базового класса с аргументами, надо использовать super(аргументы). Super должен идти первым.
  Делегирование (между наследованием и композицией). Экземпляр существующего класса включается в создаваемый, но (как в наследовании) все методы встроенного объекта становятся доступными в новом классе. 
 // Удалять объекты вручную следует в обратном порядке их созданию. Сначала завершение, затем удаление.
  Перегруженный базовый класс доступен наследникам(даже если пере-перегружен в дочернем)// если родителя можно вызвать с какими-то аргументами, то и наследника можно можно вызвать с ними.
 Наследование - "является", композиция - "имеет". При композиции встроенный объект можно(лучше) делать public, т.к. его внутренняя реализация уже сокрыта в нём само же.
  Восходящее преобразование типов. Переоход от конкретного типа к более общему. Наследник может иметь или не иметь собственные методы, но обязан содержать методы родителя.
  final константа. Для примитивов final инициализируется на стадии компиляции. static final поле (примитивного типа) - существует в единственном числе и неизменно. При использовании со ссылочными типами - ссылка на объект неизменна, но значение объекта может меняться. final можно объявлять пустыми, но инициализировать надо до запуска программы. final можно объявлять аргументы, тогда их значение можно проичитать, но нельзя изменить. final могут быть методы, но нежелательно. private метод по-умолчанию неизменен, следоватьельно final не надо добавлять. final класс не может меняться и наследоваться, его поля и методы могут не быть определены как final, но изменить или переопределить их нет возможности.
  //конструктор является static хоть и не указано. Скомпилированный код в отдельном файле загружается только когда в нём есть необходимость.
00 



















 






















