Java Быстрый старт
JavaCode(.java) -> JAVACcompiller -> ByteColde(.class) -> JVM
 
javax.imageio ImageIO - для вставки картинок  
javax.swing JFrame - новое окно
java.awt Graphics - библиотеки для рисования
java.io IOException - exception

картинки для игры надо помещать в bin/
private static Image drop;
drop = ImageIO.read(GameWindow.class.getResourceAsStream("drop.png"));

	Коллекции в Java:
коллекции - набор объектов либо пара ключ - значение. созданы для big data. 
Набор классов и методов для работы с коллекциями - Java Collections API
Основные 3 типа коллекций
LIST упорядоченный (последовательный)
SET порядок не важен 
MAP пара - ключ-значение.
редкий - Queue(очередь)
  По иерархии:
1)
 интерфейс Iterator <E> ... hasNext(); E next(); void remove(); /есть ли следующий элемент, берём его, удаляем предыдущий.	
 интерфейс Iterable <T> ... Iterarator<T> iterator(); Использует предыдущй интерфейс через метод iterator(), ИСПОЛЬЗУЕТСЯ В collection.
2)
 interface Collection <E> extends Iterable<E>
-int size();  количество элементов
-boolean isEmpty();  проверка на пустоту
-boolean contains(Object element);  содержит ли элемент
-boolean add(E element);  добавление элемента
-boolean remove(Object element);  удаление элемтена
-Iterator<E> iterator(); возвращает iterator 
3)
 множество set	/не может содержать 2 одинаковых элемента.
Включает в себя
 3.1)
    интерфейс SortedSet
 3.2)
  Реализации:
    HashSet<E> используют для сортировки где выводятся только уникальные элеменыт списка(массива). /сравнивает по ссылкам. / Set<E> mas = new HashSet<E>(); /большинство операций за О(1); / хранит в корзинках, которых по умолчанию 16.
    LinkedHashSet<E> /хранит лементы отсортированными в порядке добавления;
    TreeSet<E> implements Sortedset<E> /хранит элементы отсортированными (с помощью красно-черного дерева), большинство операций за O(log(N)); должно сравнивать элементы на входе внутрь множества(упорядочевать при добавленни);     
4)
 List
 4.1) 
    ArrayList<E> на основе массива; сложность добавления О(N), сложность доступа к конкретному элементу О(1)
    LinkedList<E> на основе двусвязного списка; сложность добавления О(1), сложность доступа к конкретному элементу О(N)
// массив строго упорядоченое расположение
в списке объект хранит ссылки на пердыдущий и следующий объекты.
односвязный только на следующий
двусвязный на предыдущий и следующий
 4.2)
    Мар<K, V>
    -HashМар<K, V>	большинсто операций за О(1)
    -TreeMap<K, V>  хранит данные уррорядочено по ключам
    -LinkedHasMap<K, V>  хранит в порядке добавления ключей.
// по сути HashSet это упрощённый HashMap у которого второе значение постоянно / HashSet<E> HashMap<E, CONSTANT>

	Stream API. (не I/O)
java.util.stream.
Stream API поток представляет канал передчи данных из источника данных (файлы, массивы, коллекции). 
 !не путать с I/O (многопоточность, inputStream, outputStream)
Стримы можно создать из коллекции, из значений, из массив и т.д

////
почитать бинарные деревья
синхронизацию коллекций
абстрактные методы 
абстрактный класс может содержать обычные методы и абстрактные, не может объекты.
если класс содержит хотя бы один абстрактный метод, то он обязан быть сам абстрактным.
Байт-код Java — набор инструкций, исполняемых виртуальной машиной Java. Каждый код операции байт-кода — один байт. Используются не все 256 возможных значений кодов операций. 51 из них зарезервированы для использования в будущем.
 SOLID — это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion. В переводе на русский: принципы единственной ответственности, открытости / закрытости, подстановки Барбары Лисков, разделения интерфейса и инверсии зависимостей

ArrayList array = new ArrayList(2);
в данном случае двойка означает размер конейнера, т.е. всего зарезервировано место под два элемента. В действительности, размер контейнера равен нулю, т.к. в нём пока нет элементов
ArrayList это списочный последовательный контейнер и элементы в нём хранятся в порядке добавления
array.add(1, 7);
означает, цифру семь нужно вставить в первый элемент, т.к. этот контейнер последовательный и порядок добавления в него слева направо, то при добавлении элемента, цифра шесть сместиться вправо и станет вторым элементом в контейнере


 
		Батруха видео для новичков
	Переменную можно объявиь:
  В классе(вне метода - "instance переменная", "свойство объекта", "поле".
- описывает характеристику объекта или просто является внутренней пременной
- уничтожается вместе с объектом
- область видимости - видна во всех методах класса
- чаще всего - имеет доступ через гетер/сеттер (но может и не иметь)
- используется модификатор доступа( даже если не указан явно)
- инициализируется по-умолчанию(если значение не указано)

 Внутри метода - локальная переменная
- уничтожается сразу после выполнения метода
- область видимости - только внутри метода
- нельзя использовать модификатор доступа 
- обязательно нужно инициализировать

Течение, поток программы (flow)
- понятие программ flow или просто flow - течение, ход работы программы (обычно изображается в блок-схемах или UML диаграммах)
- в зависимости от значения переменных ход программы может "менять направление"
- процесс работы программы - обычно последовательность вызовов методов у объектов (создается специальный "ытек вызовов"  - в каком порядке вызываются методы)
- кроме условных операторов етчение программы могут менять и другие операторы (или исключитеьлные ситуации)

	== -> Проверяет ссылки на объекты, не сами объекты. 

    Метод equals()
- используется для сравнения объектов одного типа
- если не создавать метод вручную - используется реализация по-умолчанию из класса Object
- для всех объектов желательно реализовывать метод equals()
- часто на собеседованиях спрашивают про сравнение объектов и метод equals()
- обыно переопределяют сразу 2 метода: equals & hashCode (используется для однозначного сравнения объектов и для распределинея внутри некоторых коллекций).

 Цикл используется когда надо выполнить какую-либо конструкцию кода многократно, либо до выполнения какого-либо условия. (for, while, do while)

  Комментарии применяются для 
- описания части кода
- для генерации документации на основе комментариев специального вида
 
  Рефакторинг - изменение структуры кода и оптимизация строения программы для лучшего понимания кода без изменения его функционала. В IDE есть готовый набор команд рефакторинга

  Константы.
 Константа - хранение постоянныхзанчений в классе или программе
 Константа - специальный вид переменной, котороая принимает значение только один раз
 ключевое слово final (существует слово const из других языков но не используется)
 обычно используется вместе со static
 большими буквами через _
 !!! константы можно инициализировать в конструкторе
 
 Антипаттерн - как НЕ нужно программировать. Антипаттерн "магические числа" - использование в коде числа, назначение которого непонятно (решение - создание константы с понятным именем).
 Интерфейсы часто используют как хранилище глобальных констант, т.к. в интерфейсе все переменные по-умолчанию константы.

 Режим отладки, есть похожее понятие profiling

 API - application progrmming interface - доступная функциональность программы или библиотеки
 Надо различать
  - доступ через графический интерфейс для клиента
  - доступ на программном уровне ( с использованием API)
 Существуют различные API (операционной системы, библиотек ...) - функции, доступные для внешних выовов.
 Подключает API сама IDE, но надо знать что это чаще всего jar файл с набором готовых классов. При запуске программы этот jar должен быть доступен в classpath(это параметр для JVM или компилятора, который указывает, где назодятся дополнительные библиотеки, необходимые для компиляции и запуска проекта.

	Вызовы методов
- вызов метода типа void без присвоения значения
- вызов метода и присвоение в переменную возвращаемого значения (типы должны совпадать)
- вызов меотда и передача возвращаемого значения как параметр (последовательный вызов по типу матрёшки) // объект.метод(объект.метод(объект.метод()))
- вызов метода и возврата резльтата в качестве return  для другого метода (типы должны совпадать)
- вызов метода, который в конце снова вызывет себя до тех пор , пока не выполнится определённое условие( РЕКУРСИЯ ).
  return можно использовать в void методах для досрочного выхода.
  в методе может быть несколько return (условия, циклы)
 
 Ссылки на объекты
 Ссылка - переменная, которая ссылается на объект
 Варианты ссылок: у объекта есть -
одна ссылка;
ни одной ссылки;
несколько ссылок на себя;
есть ссылка но нет объекта. //NullPointerException  
 Из-за большого кол-ва объектов появляется проблема производительности, тогда можно явно "занулить"(obj = null) ссылки на объекты.

	toString, equals, hashCode
 Это реализации по-умолчанию для всеобщего родилея Object. 

toString 
 текстовое представление объекта,
 удобочитаемый вид,
 часто вызвается автоматически, везде где нужно представить объект в виде текста

equals
 используется для сравнения объектов,
 сами выбираем критерии сравнения, 
 сравнение объектов по значениям полей объекта,
 если его не переопределить, то все передаваемые объекты при сравнении будут выдавать false
 им сравнивают ссылочные переменные
 если объект используется в коллекции, то этот метод надо обязательно переопределить.

hashCode
 числовое представление объекта(результат обработки хеш функции)
 equals и hashCode обычно переопределяют одновременно
 hashCode часто используют для объектов в коллекциях на основе hash для эффективного хранения и поиска нужного объекта
 если два объекта равны по equals то и их hashCode тоже должын быть равны( но наоборот - не обязательно: разные объекты могут возвращать один hashCode)


	Передача параметров
 - По ссылке (ByRef) - передаётся ссылка на объект
 - По значению (ByVal) - передаётся копия значения

В Java ВСЕ ПАРАМЕТРЫ ПЕРЕДАЮТСЯ ПО ЗНАЧЕНИЮ

 При передаче параметра в метод(или конструкцию) - создаётся его локальная копия, которая действует только в пределах метода(конструктора)

Varargs (String... args) ожидает неопределённое кол-во объектов.  


Разница между & и && (| и ||):
 & (|) обязательно вычисляет оба условия, тогда как && (||) вычистяет с лева на право и если натыкается на false (true) прекращает дальнейшие вычисления, т.к. результат уже полюбому будет false (ture).
 
	Стек методов
- Работа программы - набор выполняемы методов, последовательный вызов методов разных объектов.
- Стек методов (stacktrace) - "путь", по кторому прошла программа (в навигации сайта это часто называют "хлебной крошкой" - "breadcrumb")
- Для каждого потока - свой stackrace (потоки могут выполняться параллельно).

 Это нужно для :
 При возникновении обшибок - можно проследить путь ошибки, с кагого момента началась
 Можно узнать "маршрут" вызовов в любой момент.

 Режим  Debug позволяет в любой момент посмотреть стек. //стек тип коллекции "последним зашёл - первым вышел".

 JAR файлы. Часто под библиотекой подразумевается именно JAR файл. Библиотеки имеют свою версию, которая указывается в файле MANIFEST.MF
- в нём указывается класс с методом main для запуска
- содержится версия библиотеки( так же может формировать версию сборки из системы котнроля версий
- содержится ссылка на подключаемые библиотеки
  
	Массивы
 Нужын для хранения набора данных определённого типа( примитивного или ссылочного). Каждый элемент определяется индексом(порядковым номером).
 Делятся на одномерный и многомерный (каждый элемент массива сам является массивом)
 Главные минусы 
- неизменяемый размер указывается при объявлении массива.
- часто - путаница в многомерных массивах
- более сложные структуры данных (связанный список, очередь и т.д) через массивы реализовывать не так удобно (для этого существуют специальные коллекции)
 Служебные классы Arrays и Array
- Arrays - класс-утилита: содержит различные методы по работе с массивами (сортировки, заполнения, вычисления)
- уменьшает количество лишнего кода - можно использовать готовые решения
- По аналогии свществует класс Collections - для работы с коллекциями
- Array - класс-утилита для быстрого создания массивов, получение элементов.(используется не так часто, т.к. дублирует Arrays) 
  Массив - это отдельный объект. Два массива с одинаковыми значениями элементов - разные объекты, у каждого свой адрес хранения в памяти.
 Массив может принимать элементы только одного типа, указанного при создании.
 На практике чаще всего используют коллекции, а не массивы. Но многие коллекции основаны на массивах.
 Сортировка (ascending)int mas = new int[6]; Arrays.sort(mas);
 Обратная сортировка (discending) Integer mas = new Integer[6]; Arrays.sort(mass, Collection.reverseOrder());

 ENUM перечисление
Применяется для хранения констант. Он объединяет константы по смыслу. Часто называется "ПЕРЕЧИСЛЕНИЕ".
 Может использоваться в :
-условиях,
-циклах,
-типах переменных,
-типах возвращаемого значения метода
 Ключевое слово enum:
 - указывает компилятору, что используется специальная конструкция enum, пишется вместо "class".
 - часто называют enum-классом,
 - не путать с интерфейсом Enumeration (аналог итератора)
 - можно использовать конструкторы. // вродебы(сеттеры не используют, т.к. значения передаются параметрами в конструктор).
  Есть метод .values() возвращающий массив значений. .getName() .getIndex

// Alt + Ins переопределени методов
// Нех - шестнадцатиричная система
// node.js - backend /

	Collections
 JCF Java Collection Framework - частоназывают набор классов и интерфейсов в Java для работы с коллекциями:
- Коллекция - группировка объектов определенного типа, например коллекция товаров магазина
- JCF имеет продеманную иерархию интерфейсов и классв (можно даже изучить их, для понимания ООП)
- Существуют готовые коллекции под различные задачи (очередь, связанный список, индексированный список и т.д.)
- Чаще всего коллекция используется для хранения объектов
- Многие фреймворки ORM (Object Relational Mapping) основаны на коллекциях (Hibernate, JPA)
 Набор системных классов и интерфейсов по работе с коллекциями, построены по принципам ООП
  - Интерфейсы -> Абстрактные классы -> Классы реализации
 Разделяют:
  - абстрактный уровень (описание поведения разных типов коллекций), задает API
  - уровень рефлизации- конкретыне классы (имплементация) для различных типов коллекций.

 Сходства с массивом:
- Коллекция - это набор данных определённого типа
- Коллекция имеет имя (ссылка на участок памяти, где хранится коллекция)
- В основе многих коллекций лежат массивы (можно изучить исходный код для понимания)

 Различия:
- Динамическое изменение размера по необходимости (у массива строгий размер)
- Коллекция не может хранить примитивы, надо использовать оболочки
- Более удобная работа с набором данных
- Готовые коллекции для решения множества задач.

		Интерфейсы JCF
 Collections:
	Set - неупорядоченный набор
- не содержит одинаковых значений (дубликатов)
- аналог множества в математике
	Lis - каждый объект имеет свой индекс, по которому его можно быстро получить 
- может содержать дубликаты
	Queue -односторонняя очередь
- может использовать принцип FIFO	
	Deque - двусторонняя очередь
FIFO
LIFO

 В интерфейсе JCF но не в Collection
	Map - коллекция типа "ключ-значение"
- уникальность ключей
	SortedSet отсортированный Set
	SortedMap отсортированный Map

   Следует запомнить:
 Готовые интерфейсы даля разных типов коллекций
 Большое количество реализаций(посмотреть в дереве наследованя IDE)
 В каждой коткретной задаче надо применять коллекцию, которая больше всего подходит под требования
 Сначала надо понять стурктуру JCF потом уже укреплять знания API на практике
 Системные классы по работе с коллекциями (как и многие другие) построены по принципам ООП
    - Интерфейсы -> Абстрактные классы -> Классы реализации

    Структура классов коллекций
 Паттерн "итератор":
-возможность перобора всех элементов объекта
-о можно использовать для любой структуры данных, где существует набор данных(не обязательно только в коллекциях)
-существует готовый интерфейс Iterator, который можно использовать "из коробки"(в JDK)

 Итератор в коллекциях:
- реализовывается с помощью интерфейса Iterable (прилагательное Iterator)
- Iterable - это стандартный Iterator, но с дополнительными реализованными методами
- Все дочерние классы от Collection поддерживают итераторы
- Интерфейс Map напрямую не наследуется от Iterable, но его ключи или значения ключей могут быть пробразованы в Set, который поддерживает итерацию.

  Понятия ORDERED и SORTED

ORDERED 
  Порядок вставки (хранения) объектов - какой объект за каким следует
  Не зависит от значений объекта (не привязан к ним)
  Например, ArrayList - в какой последовательности добавляли объекты - в такой и можете получить

SORTED
  Сортировка объектов по определённому правилу
  Зависит от значений объекта (привязан к ним) - условия сортировки вы можете выставлять самостоятельно по любому полю/полям (либо использовать реализацию по-умолчанию)
  Последовательность вставки может быть любой, но при переборе отсортированной коллекции - вы получаете их в нужном порядке.

 Подробнее о каждой коллекции

		Интерфейс SET
 Аналог математического множества
 Не может содержать дубликаты (Collection - может), при добавлении дубля - происходит замена старого значения (- для сравнения испоьллзуется метод equals)
 Нельзя получить элемент по индексу (как в List)
 Перебор (пролистывание) элементов с помощью итератора или цикла
Популярные реализации: 
 HashSet	TreeSet		LindekHashSet		EnumSet
Отличаются по скорости и условиям применения. // самый быстрый HashSet
  Следует использовать:
- Когда все объекты должны быть уникальными
- не нужно периодически получать (выдёргивать) элементы по индексу 
 Называют самой примитивной коллекцией (просто хранит набор данных)
 При необходимости - перебор по всем элементам	
	Популярные реализации SET (используют интерфейс Map. В основе лежит hash, поэтому метод hashCode обязательно реализовывать)
 - HashSet В основе HashSet лежит HashMap. HashSet - notOrdered/notSorted (не хранит порядок). самый быстрый и простой
 - TreeSet - Sorted Хранит значения в упорядоченном виде (он сортирует их по каким-либо признакам). расширяет NavigableMap. Самый медленный
 - LinkedHashSet Является Ordered/notSorted (строгий порядок), расширение класса HashSet 

	Типизированные коллекции
	Типизация
  Использование  только тех объектов, которые нужны по задаче
  - Лучшая формализация
  - Проверка ошибок на этапе компиляции
  - Чем строже код - тем меньше ошибок
  В коллекциях - типизация нужна для того , чтобы можно было добавлять только объекты определенного типа (или любой дочерний то этого типа)
  - Использование полиморфизма
  - В типизированные коллекции можно добавлять только определённые объекты
  Понятие "Generics"
  Всегда следует использовать типизированные коллекции.

	Интерфейс LIST
  - Можно добавлять дубликаты (в отличие от Set)
  - Можно получать элемент по индексу (как в массиве)
	Популярные реализации
ArrayList	LinkedList	Stack(устаревшее)	 Vector(устаревшее)
 Понятия  Synchromized и Threadsafe
 -Threadsave(Thread Safety) - добавление возможност корректной работы с данными из нескольких потоков (чтобы они не мешали друг другу)
 -Synchronized (Synchronization) - способ достижения Threadsave - блокирвка ресурса во время работы и раблокировка по окончанию, последовательный доступ к ресурсу (объекту, коллекции)
   Synchronized коллекции:
- Stack(устаревшее) 
- Vector(устаревшее)
- Более медленная работа из-за синхронизации (даже когда это не нужно)
   Не Synchronized коллекции:
- ArrayList
- LinkedList
- Более быстрая работа
- Можно создать синронизированную коллекцию с помощью метода Collections.synchronizedList()
//Stack(устаревшее) современный аналог - ArrayList; Vector(устаревшее) современный аналог - LinkedList
	Связанный список (двунаправленный и однонаправленный
- ArrayList (чаще используется, удобнее)
  получение элемента по индексу
  Ordered
  В основе реализации лежит массив
  Индексация с нуля
  Преимущество в скорости (получение и записть объекта по индексу)
- LinkedList
  В основе реализации лежит "двунаправленный связанный список" (двусвязный список) - можно проходить в обоих направлениях
  Ordered
  Часто используется для создания очереди, стека
  Преимущество в скорости (добавление и удаление объекта)
// addFirst/addLast 
FIFO = ОЧЕРЕДЬ 			
LIFO = СТЕК
	
    Класс Collections
 Класс-утилита с готовыми служебными методами для работы с коллекцийе (по аналогии с Arrays):
  - Копирование, Поиск, Замена (swap), Сортировка, Создание синхронизированных коллекций и т.д.
	Compare и Comparable нужны для создания правил сортировки объектов в коллекции
    Типы сортировок:
  Вручную
    - с помощью Collections
    - создание своего алгоритма сортировки
  Автоматически
    - в коллекциях с автоматической сортировкой (TreeSet, TreeMap)
Comparator (если надо создать несколько типов сортировки)
  Реализация в отдельном классе
  Можно создать несколько типов сравнений
  Метод Compare (если нужен только один вид сортировки)
Comparable
  Реализацияв том же классе
  Тоьлко один критерй сравнения
  Используется по-умолчанию, если не указан Comparator для сортировки
  Метод compareTo

 	Queue Deque
   Отличие от стандартных списков - дополнительные методы для организации очередей, стеков.
 Queue - интерфейс с возможностью построения очереди способом FIFO
 Deque - поддержка как FIFO так и LIFO
   Реализации:
LinkedList(связанный список)	PriorityQueue(ordered очередь, используем Comparable/Comparator)	ArrayDeque(использует массив).
   Основные понятия
Head - голова, начало очереди. End - хвост, конец очереди.
Head и End совпадают - это стек
Head и End не совпадают - это односторонняя очередь
Bounded Queue - ограничение на количество элементов (пакет java.util.concurrent.*)
Unbounded Queue - неограниченное количество элементов (пакет java.util.*)
  Получение элементов очереди: с удалением / без удаления
  Класс Collections реализует служебные методы, Создание очереди LIFO
	
	Map - хранит набор данных по принципу "ключ-значение"
    - ключом и значением могут быть любые объекты
    - ключи должны быть уникальны
    - каждому ключу соответствует одно значение (любой объект, в том числе и коллекция)
  Понятия
    - Key - ключ, по которому ищется объект-значеине
    - Entry - объект-значение (может быть другой коллекцией)
  Интерфейсы
    - SortedMap	- сортировка объектов коллекции на основе ключей
    - NavigableMap - расширение SortedMap с возможностью сравнения (lower, higher, ceilig, floor)
// Часто - можно не использовать Map, а вместо него лучше подойдёт List
   Популярные реализации (по аналогии HashSet, TreeSet, LinkedHashSet)
    - HashMap - набор объектов (без сохранения порядка вставки), основан на хэш таблицах, максимальная скорость
    - TreeMap - сортирует по ключу, основан на дереве
    - LinkedHashMap - сохраняет порядов вставки объектов по ключам, основан на хэш таблице + связаный список.
  Изучение отличий коллекций:
   Реализация интерфейсов
    - можно понять общий характер работы
   Просмотр метода add из структуры (или put)
    - внутренности кода - какие структуры используются для хранения данных
   Наличие возможных конструкторов
    - использование Comparator, начального размера и других параметров 

EnumSet
 Объединение значений enum по смыслу
   Пример: группировка дней недели(рабочие, выходные)
EnumMap
 Ключ - значение enum
 Значение - любой объект
   Пример: группировка коллекций по типам.
	Как выбрать коллекцию:
 Поначалу- научиться работать с популярными реализациями, потом переходить к более сложным реализациям.
 При выборе - сначала выбираем интерфейс в зависимости от задачи - после этого конкретную реализацию.
 На скорость пока можно не обращать внимания(когда дойдёт до больших массивов данных, тогда начнём).

 Критерии выбора для начала работы:
Порядок:
 - Выбрать интерфейс (Set, List, Queue, Map)
 - Многопоточность
 - Порядок вставки
 - Сортировка
 - Ограничение по размеру
 - Каких операций обльше: вставки иои получения
Помнить про типизацию
Запоминаем таблицу:
 http://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html
НА ЭТОМ ПО КОЛЛЕКЦИЯМ У НЕГО ВСЁ



	0ОП
Как пишется профессиональный код. последовательность
Чёткий анализ требований и функций -- проектирование -- реализация -- тестирование -- анализ производительности -- оптимизация -- доработка -- и заново с проектировния..

Что необходимо изучить 
 Проектирование
  Анализ требований и функционала, создание основных линий поведения объектов программы, использование UML
 OOП
  Создание универсального и расширяемого кода с правильным набором объектов
 Синтаксис
  Основные конструкции языка, возможности и сокращения, быстрый набор кода
 UI
  Создание графических оболочек, для выполнения вашего функционала

Виртуальная машина написана на С++, существуют версии под каждую ОС. существует много версий, основная HotSpot.
 JVM java virtual machine для пользователя, запуск, минимум утилит 
 JDK java development kit для разраба JVM + инструменты компиляции, много утилит. 
Как работает: файл.java компилируется в байт код (скомпилированый файл.class) -- происходит сборка проета (она зависит от его типа(веб, десктоп, андроид) -- запуск в JVM -- выполнение

JavaSE - мнимальный набор библиотек для запуска консольных и десктоп приоложений. Входит во все остальные пакеты
JavaEE - разработка серверного программного обеспечения. Веб проекты. JavaSE + дополнительные библиотеки
IDE Integrated Environment Development
Главные понятия ООП: Наследование, Полиморфизм, Инкапсуляция, Абстракция, Композиция, Объект.

	Главный принцип написания кода
  Сначала абстракция -- потом реализация. Это нужно для:
- Ограничения возможностей - чёткое понимание что и как должно работать, разделение полномочий между объектами
- Расширяемость - правильно составленный уровень абстракций позволяет создать любое количество реализаций, лёгкая доработка кода
- Абстракция - один из главных принципов ООП
 абстракция (поведение) как должен работать объект. Поведение- ограничение объкта в действиях и возможностях.
 Спецификации - описание поведения API какой-либо технологии без конкретной реализации. Или же: документ, в котором описаны правила и возможности использования.
 Программа - набор объектов, которые взаимодействуют между собой

	 КЛАССЫ И ОБЪЕКТЫ
  Класс - оснвной элемент кода, основная конструкция кода
  Класс задаёт возможные свойства (характеристики)
  Разные объекты могут иметь одинаковые свойства
  Класс- шаблон без значений свойств (или со значениями по-умолчанию), объект - с конкретными значениями.
  Объект задает конкретные значения свойств при создании
  Объект - класс с определёнными свойствами, создаётся только на основе класса
  Объект может быть создан с пустыми (незаполненными) свойствами.
  new - создание объекта.
  Свойства объекта
 Методы - возможные действия объекта.
 Класс(объект) - набор характеристик (свойств) и методов (действий)
 Свойства - переменные, действия - методы
 Объект может не иметь свойств и/или методов (может быть и "пустым")
 Создание объекта - правильный набор свойств и методов.	
 
	Модификаторы доступа
 Нужны чтобы урезать или открывать область видимости элемента
 Удобней работать с объектами
 Сокрытие внутренней реализации 
 Предоставлять доступ только определённым классам, методам или переменным
 НЕ СЛУДУЕТ ИСПОЛЬЗОВАТЬ NONE
 В одном файле должен быть только один public класс
public доступен в: class/package/subclass/world		protected доступен в: class/package/subclass/
none доступен в: class/package
private доступен в: class

	Инкапсуляция
 Рзделение кода на внутреннюю (скрытую) и внешнюю (видимую). Способ реализации инкапсуляции.
 Для доступа к переменным класса (свойствам) - используются геттеры и сеттеры.
 get - получить, set - записать.
 переменные чаще всего имеют модификатор private, геттеры и сеттеры - public

	Переменная - именованная область памяти для хранения какого-либо значения.
 Можно объявить в : классе(inctance), методе, параметре метдоа.
 Типы переменных : примитивные (хранят обычные значения/ string - исключение). 
текст(char/string) 
числа(byte/double/float/int/long/short)
логические(boolean)
 ссылочные
все остальные

 Объекты и примитивные значения хранятся в разных областях памяти
 Переменные внутри метода объявляются без модификатора доступа

	Конструктор - способ создания объекта с заранее заданными свойствами(начальным состоянием).
 Не путать с методом. 
 Объект может иметь несколько конструкторов.
 Имя конструктора - это имя класса
 Если никакой конструктор не указан - компилятор создаёт конструктор по-умолчанию.
 Следует различать конструктор По-умолчанию от конструтктора без параметров(Созданного-вручную)
 По-умолчанию создаётся только если нет созданного вручную
 У конструктора  нет возвращающего значения.
 Конструктор - задаёт значение свойств перед созданием объекта(вызывается только один раз при создании объекта) 
 Геттеры/сеттры - задаёт занчение свойств после создания объекта(можно вызвать любое кол-во после создания объекта)
  














// разобрать компарабал и iterateMap, xml
http://docs.oracle.com/javase/8/docs/index.html

	Многопоточность
 Необходимо создать класс наследующийся от Thread, в нём переписать/переопределить(@Override) метод run().  


