Платформонезависимость и сборщик мусора основопологающие языка разработанного в 1995 году
апплет в теории приложение которое можно выкачать в браузер и в нём оно выполнит какую-то логику, какие-то действия
с 1995 по 2000 популярны апплеты для браузера; с 2000 по 2005 приложения для мобольных; с 2005 по 2014 сервера; всю дорогу с 1995 по 2014 приоложени для бытовых приборов.
 Кроссплатформенность в реальности:
Классические варианты испольнения:
Компилятор - поставляем исходники, перед стартом собираем. Минусы: код доступен всем, собираться перед исполненеим может очень долго. (долго работеает с исходниками)
Интерпретатор - поставляем скрипты, сразу начинаем медленно выполнять. Минусы код не защищён(тоже предоставляются исходники), само приоложени будет очень медленно.
Гибридное решение:
Вначале компилируем свой код в архитектурнонезависимый байт-код (инструкции для виртуальной машины JVM) и передаём его на исполнение виртуальной машине JVM (для кажой архитектуры она своя) которая будет превращать байт-код в компьютерный код, а уже он будет испольняться машиной  (один и тот же байт-код все JVM исполнят одинаково). 
 Ключевые приемущества Java:
Кросплатформенность. Написано один раз - работает везде. Встроенный сборщик мусора. Безопасность исполнения (весь код проходит через JVM).
 Что вышло из задуманного: 
- нет переносимых приложений, но есть "переносимые" программисты.
- сборщик мусора иногда может быть не вовремя.
 Почему Java?
Это язык высокого уровня с простым и понятным синтаксисом,
Большое количество специалистов использующих Java,
Большое количество библиотек, 
Постоянные улучшения и доработки,
Документация
// Всё же сейчас популярен не благодаря основополагающим приемуществам (платформонезависимость и сборщик мусора), а благодаря тому во что он вырос.
 Основы:
Один класс - один файл (имя файла - имя класса)
А а; (осздание ссылки на объект), А а = new А(); создание объекта.
  Платформа Java:
Для запуска используются и необходимы (пользователю):
Java Runtime Environment (JRE) то что позволяет исполнять Java приложения на машине в своей ОС. В состав входят:
 Java Virtual Machine (JVM) виртуальная машина и
 Class Libraries библиотеки классов
Для создания приложений (разработчику):  
Java Development Kit (JDK) это 
 JRE плюс  Java compiler
IDE - не входит в соста Java
  Обзор составляющих JVM:
Byte code verifier сначала проверяет
Interpreter либо преобразует по ходу выполнения 
Just-in-Time (JIT) compiller либо компилирует а потом выполняет
Garbage collector (GC)
 Javac
 Превращает *.java *.class
 *.class можно собрать в *.jar(zip архив)
// байт-код скомпилированы с Питона тоже запустится на JVM
// куча (heap) место для создания новых объектов, Стэк (stack) место для создания ссылок на объекты и работы с ними. Т.е. A a (это в стэке) = new A() (это в куче);
GC удаляет объект если по его (или на него) ссылкам не добраться до стэка.
  Редакции Java:
Java SE (Standard Edition)
 Стандартная редакция 
 JVM + библиотека классов
Java EE (Enterprise Edition) отличие в том что в запущеный JVM помимо своего приложения можно поселить ещё некий набор сервисов, которым может пользоваться ваше приложение, даже которые смогут вызывать ваше приложение. Т.е. запуск приложения в окружении с которым вы работаете и всё это внутри JVM.
 Java SE
 Спецификация (описание требований к устройству сервисов внутри JVM)
 API + runtime environment services
Java ME (Micro Edition) 
 Мобильные телефоны, бытовые приборы
  Правила именования в Java:
Классы в Java собирают в пакеты (packages)
Пакеты обычно собирают в *.jar файлы (zip архивы)
Класс может быт однозначно идентифицирован по полному имени packageName.directoryName.ClassName
Имена пакетов и директорий принято начинать с маленькой буквы
Имена классов: MySuperClassName
Имена функций: getMyVariable()
Имена переменных: myVariable
Пакеты не могут иметь циклческих зависимостей

//applet - сущность расширяющая возможности браузера. на frontend, на backend - Servlet
  Сервлет это 
-класс расширяющий возможности сервера
-как applet,только на web сервере
-java решение для создания динамических страниц
-объект, который обрабатывает http запрос (request) и возвращает ответ (response) - html страницу

ServletContainer часть web сервера, содержащая сервлеты. Связывает URL с сервлетом

Шаблонизаторы - библиотеки позволяющие совместить данные полученные из текстового файла и полученные динамическим путём. // например <freemarker>

Регистрация
 Фронтенд
  1 Страница с вводом: логин, имейл, пароль.
 Бэкэнд
  1 Сервлет обработки запроса
  2 Класс AccountService с методом регистрации
  3 Класс UserPofile с полями: логин, имейл, пароль
  4 Карта логин -> UserPofile
Авторизация
 Фронтенд
  1 Страница с вводом: логин, пароль.
 Бэкэнд
  1 Сервлет обработки запроса
  2 Класс AccountService с методом авторизации
  3 Поиск UserPofile в карте по логину
  4 Карта HttpSession -> UserPofile
Учётная запись
 Фронтенд
  1 Страниа после логина
 Бэкэнд
  1 Сервлет обработки запроса страницы
  2 Получение HttpSession из request-a
  3 Поиск UserPofile в карте оп HttpSession  
Выход
 Фронтенд
  1 Кнопка выхода
 Бэкэнд
  1 Сервлет обработки запроса 
  2 Получение HttpSession из request-a
  3 Удаление UserPofile в карте по HttpSession

List<String> - это generic класс ( можно использовать наследников List : ArrayList, LinkedList и т.д.)
  Разница:
наследование - принцип "разновидность чего-то" (is a)
шаблон - принцип "специализируется на "(of something)
List - использование без типизации deprecated
