
 most popular: commit, branch, checkout, cherry-pick, reset, revert, rebase, merge
 Слияние: merge "имя ветки КОТОРУЮ мержим", rebase имя ветки КУДА ребэйзим"
HEAD всегда указывает на последний коммит (простой checkout C4 преносит его туда)
Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту  (просто checkout C4; где С4 это идентификатор/hash)
checkout C4^ значит переключится на первого родителя(ближайшего) ^^ на второго и т.д. (если ^ надо много использут тильду ~ c числом количеством. У ^ число значит мержевого родителя 1 или 2) Их можно указывать вместе скопом.
Можно напрямую прикрепить ветку к коммиту при помощи опции -f (forced) Например, команда: git branch -f master HEAD~3
 Теперь команды отмены изменений: reset HEAD~1 - local; revert HEAD^ - remote commands
 Команды внесения изменений
git cherry-pick <Commit1> <Commit2> <...> - копировать несколько коммитов на место, где сейчас находишься (HEAD), хорош когда знаешь точные идентификаторы коммитов.
rebase -i КУДА КАКОЙ - перетасовка коммитов через отдельное меню 
tag V1 C1 созадём постоянную ссылку V1 на коммит C1(по-умолчанию HEAD)
git describe <ref> - показывает насколько далеко коммит от ближайшего. Выдаёт: <tag>_<numCommits>_g<hash>, 
Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.
<удалённый репозиторий>/<имя ветки>
git fetch - скачать из удалённого репозитория
git pull - аналог fetch + merge, git pull --rebase - аналог fetch + rebase



	/\/\/\/\/\/\/\
	     Jenkins
jekaroze 1q2w3e4r5t6y7
jenkins  это служба windows. win+r sirvices.msc
при установке оставили 
dasborad view
workspace Cleanup
junit
pipeline
build pipeline
piarameterized trigger
copy artifact
git
matrix project
ssh slaves
windows slaves
mailer
iteno
Основные триггеры: on-demand по клику, other job finished по завершении другой задачи, Cron schedule расписание cron, SCM check это git
 CRON выражения * любой, /5 который делится нацело на 5, можно указывать через запятую или дефис
           /\/\/\/\/\/\/\/\/\/\
	   JavaScript
IDE
    Visual Studio Code (бесплатно).
    WebStorm (платно).
Light
    Atom (кроссплатформенный, бесплатный).
    Sublime Text (кроссплатформенный, условно-бесплатный).
    Notepad++ (Windows, бесплатный).
    Vim и Emacs тоже хороши, если знать, как ими пользоваться.
Если атрибут src установлен, содержимое тега script будет игнорироваться.
Инструкции – это синтаксические конструкции и команды, которые выполняют действия.
Когда 'use strict' находится в начале скрипта, весь сценарий работает в «современном» режиме. должен быть в первой строке. Нет никакого способа отменить use strict
Можно так:
'use strict'; <Shift+Enter для перехода на новую строку>
//  ...ваш код...
<Enter для запуска>
Всегда используйте «use strict»
    Имя переменной должно содержать только буквы, цифры или символы $ и _.
    Первый символ не должен быть цифрой.
технически возможно создать переменную простым присвоением значения без использования let. если мы не включаем use strict
 неизменяемая переменную, используйте const вместо let:
 константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений. строчными буквами обозначаются константы, значения которых вычисляется, не задано по-умолчанию.
 Дополнительная переменная – это добро, а не зло.
 Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число
динамически типизированными
Есть восемь основных типов данных в JavaScript.
Числа: целые, с запятой, специальные числовые значения Infinity(результат деления на 0), -Infinity и NaN
Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться со строками как с числами и т.д. худший результат - NaN
Тип BigInt ( больше, чем 253) был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины. Число должно заканчиваться n (123n), поддерживаются только в браузерах Firefox и Chrome.
Строка (string) в JavaScript должна быть заключена в кавычки.
Двойные или одинарные кавычки являются «простыми», между ними нет разницы. Обратные кавычки позволяют нам встраивать выражения (их результат) в строку, заключая их в  ${вычисляемое выражение}, . 
// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, значение name.
// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3
Нет типа char.
Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).
Специальное значение null не относится ни к одному из типов, описанных выше.
Оно формирует отдельный тип, который содержит только значение null. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.
Тип object. Тип symbol
    Синтаксис оператора: typeof x.
    Синтаксис функции: typeof(x).
typeof null является "object" - намеренная ошибка языка.

преобразование примитивных значений
alert(value) или  функция String(value) преобразует значение к строке. Преобразование происходит очевидным образом.
Численное преобразование происходит в математических функциях и выражениях.
Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN
undefined 	NaN
null 	0
true / false 	1 / 0
string 	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.
Все математические операторы выполняют численное преобразование, только если одно из СЛАГАЕМЫХ(+) является строкой, тогда и все остальные приводятся к строкам.
Следует помнить что операции выполняются последовательно, слева направо.

Логическое преобразование
    Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
    Все остальные значения становятся true.
любая непустая строка это true
null становится 0 после численного преобразования.
undefined становится NaN после численного преобразования.
Пробельные символы, такие как \t и \n по краям строки игнорируются при преобразовании в число.
	Операнд – то, к чему применяется оператор, Унарный - применяемый к одному операнду, бинарный - применяется к двум операндам.
"+" преобразует нечисла в числа (true/false в 1/0) то же самое, что и Number(...), только короче.
alert( +apples + +oranges ); // 5 //тоже самое, но более длинный вариант alert( Number(apples) + Number(oranges) ); // 5
 Приоритет: унарный +/-,*,/,+,-,=. Все операторы возвращают значение.
 a % b – это остаток от деления a на b
 Оператор возведения в степень ** недавно добавили в язык. Для натурального числа b результат a ** b равен a, умноженному на само себя b раз.
 Увеличение/уменьшение переменной на единицу - Инкремент/декремент, можно применить только к переменной. 
Если хочется тут же использовать результат, то нужна префиксная форма, Если нужно увеличить и при этом получить значение переменной до увеличения – постфиксная форма
Операторы ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у арифметических операций. Инкремент/декремент можно использовать в любых выражениях
   Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.
    AND(и) ( & )
    OR(или) ( | )
    XOR(побитовое исключающее или) ( ^ )
    NOT(не) ( ~ )
    LEFT SHIFT(левый сдвиг) ( << )
    RIGHT SHIFT(правый сдвиг) ( >> )
    ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
  Сокращённая арифметика с присваиванием - += и *=.
  Оператор запятая предоставляет нам возможность вычислять несколько выражений, разделяя их запятой. Каждое выражение выполняется, но возвращается результат только 
последнего.
Оператор строгого равенства === проверяет равенство без приведения типов.
	Сравнение.
  Строки сравниваются последовательн посимвольно. Сравнивается нумерация символов в кодировке Unicode Б>А.
 При сравнении разных типов каждое значение приводится к числу. true = 1, false = 0, ' ' = 0.
Оператор строгого равенства === (строгого неравенства !==) проверяет равенство без приведения типов. Попытка сравнения разных типов даёт false.
null == undefined - true, null === undefined - false. При других сравнениях <= >= и т.д. null - 0 undefined - NaN. null == undefined равны друг другу и ничему больше.
null > 0, null == 0 - false, но null >= 0 - true. > и >= работают по-разному.
  Alert, prompt, confirm. Вид и расположение зависят от браузера.ва
 alert('text'); показывает сообщение.
 prompt("text", 'default');  показывает сообщение, запрашивает ввод текста, есил OK выводит этот текст, если Отмена или Esc то null.
  let a = prompt("text", 'default'); alert(`you text is ${a}`);
 confirm("text"); показывает сообщение и ждёт, если ОК то ture, если Отмена или Esc то false.
  let b = confirm("Confirm?"); alert(b);
	If, else, else if.z
 0, " ", null, undefined, NaN  -  falsy (принимают значение false), остальные  -  truthy (принимают значение true).
	тернарный оператор
 let a = условие ? значение true : значение false.
 Несколько знаков ?.
 (а < 20) ? '<20' :
 (a < 40) ? '<40' :
 (a < 50) ? '<50' :
 '>50;  условия проверяются по порядку.
  || или сравнивает значения до первого true. аналог if. Возвращает первое истинное значение или последнее ложное (если нет истинных)
  && и сравнивает значения до первого false.  аналог if. Возвращает первое ложное значение или последнее истинное (если нет ложных) 
  приоритет ! выше чем у &&, а у && выше чем у ||.
  ! не !! используют для приведения к логическому типу первый ! приводит к противоположному логическому, второй ! оставляет логическим, но инвертирует значение к 
начальному. Аналог "!!значение" встроенная функция "Boolean(значеине)".
  вызов alert(1) не возвращает true/false, а undefined. //Вот тут не разобрался полностью.
	while
 итерация - выполнение тела цикла. 
 встроенное объявление переменной, объявление переменной внутри цикла (for) вне цикла её не существует.
 break - прервать цикл, continue - пропустить цикл. Не используются с тернарным оператором
 используются метки, т.к. break/continue действуют только на текущий цикл не на высшие. Метка:, вложенные циклы, break/continue Метка. прервёт/пропустит все циклы внутри
Метка.
 префикс или постфикс инкремент/декремент - для while имеют значени, для for нет.
	Switch (а) { case a: alert('smt'); break; default: alert('smt else');}
 проверяет на строгое равенство. ===, Swich и case допускают любое выражение в качестве аргумента.
	Функции
 function name() { alert('smt')}; локальные переменные - объявленные внутри функции не видны снаружи. А внешние можно использовать внутри, даже изменять их. При 
одинаковых именах внешней и внутренней - предпочтение отдаётся внутренней. Аргумент функции можно задать по-умолчанию, типа text = "smt". Это значение будет 
использовано только если значение text не будет задано( text === undefined)
 Глобальная переменная - переменная видная для любой функции.
 return без значения приводит к немедленному выходу из функции.
 функция не возвращающая значения === undefined. 
 никогда не переносить выражени return на отдельную строку, JS подставит после return ;.
















  


	   /\/\/\/\/\/\/\/\/\/\
	JetBrains Java
Since Java 11, you can write var



 Это список сайтов указанных на Андерсоне:
Codecademy, Udacity, Code School, Treehouse, FreeCodeCamp, Udemy, Coursera, Codewars, Codingame, Khan Academy, edX, W3Schools, Hackr.io, Bento.io, Solo Learn, Codeasy.net, Edabit, GITHUB, Sitepoint, Crunchzilla, One Month, LearnCode. Academy, Thenewboston, Derek Banas, Programming Knowledge, Softwarehow, Marksheet, Shay Howe, NodeSchool, Learn JS, JavaScript.com, LeetCode, Skillbox, Нетология, Geekbrains, SkillFactory, HTML Academy, Hexlet, JavaRush и другие.
