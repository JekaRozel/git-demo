byte a = 1;
byte b = 2;
byte c = (byte)(a+b); (без обязательного приведения типа не выйдет?)
Автоматическое расширение?
  Классы-обертки : названия отличаются только у Integer Character.
int a = 0;
Integer b = Integer.valueOf(a); //boxing
int c = b.intValue();  // unboxing
Они полезны чтобы хранить символы и числа в коллекциях(они не поддерживают примитивные типы); или для выражения факта отсутствия значения (в переменной ссылочного типа хранить null или ссылку на значение).
Они поддерживают неявное преобразование и над ними можно выполнять операции(но они сами извлекают значение, выполняют операцию, обратно заворачиваются).
  
 Конвертация в строку: String str = Long.toString(12345);
 Конвертация из строки: long a = Long.parseLong("12345");
   В числе 2 в степени n в единицу выставлен только (n+1)-й бит. Все остальные — нули. Например, числа 16 и 32 имеют двоичный вид, соответственно, 10000 и 100000. Если с такими числами выполнить побитовое ИЛИ, то в результате должен получиться 0. Например: 32 & 31 == 0 //true
	Ссылочные типы : МАССИВЫ СТРОКИ
  Объявление переменной не создаёт бъект а объявляет ячейку памяти которая может в будущем содержать ссылку на объект.
Объект создаётся оператором new, который выделяет место под объект и вызывает конструктор(метод инициализирующий внутреннее состояние объекта соответствии с переданными параметрами)
??  тип[] a = new тип[] {1, 2, 3,} НО!!! Если переменная объявляется и инициализируется в одной строчке то можно не использовать new тип[]!! тип[] a = {1, 2, 3,} ??
        varargs
  static int a(int[] numbers) {...} a(new int[]{1,2,3}) простое объявление массива с фиксированным числом элементов, отличное от него
varargs - Объявление метода принимаюещго переменное кол-во параметров: static int b(int ... numbers) {...} b(1,2,3) // многоточие влияет только на то как метод можно вызывать, отальное всё работает также как в обычном массиве. 
  Сравнение:
== сравнивает ссылки (ссылаются ли две переменные на один и тот же объект.
.equals()- метод сравнивающий объекты по содержимому (для массивов он не работает, тоже сравнивает ссылки). Для попарного сравнения содержимого массивов надо использовать Arrays.equals(mas1, mas2);. Это для одномерных, для многомерных : Arrays.deepEquals(mas1, mas2); 
!!! import java.util.Arrays; Много полезного !!!
  Распечатка(вывод на консоль) массива:
System.out.println(mas); - выдаст ссылку на ячейку памяти [I@123445]
System.out.println(Arrays.toString(mas)); - выдаст массив
System.out.println(Arrays.deepToString(mas)); - выдаст многомерный массив
char[] charArray = {'a', 'b', 'c'} - массив символов
String string = new String(mas); - строка из массива символов
char[] fromMas = string.toCharArray(); - массив символов из строки
Определение: Строка это ссылочный тип хранящий последовательность символов произвольной длинны // в отличии от других ЯП строка не должна заканчиваться нулевым символом он может использоваться внутри. // длинна строки храниться в отдельном поле
  Неизменяемость - фундаментальное свойство строк в Java. Но для строки String s = "asdsdasd" можно:
int length = s.length(); - узнать длинну
char firstChar = s.charAt(0); - получить символ по индексу
boolean endsWithTable = s.endsWith("table"); - содержит ли суффикс, префикс
boolean containsIs = s.contains("Is"); - содержит ли подстроку.
  Изменение строки связано с созданием нового объкта (возвращением новой строки результата)
String substring = s.substring(0, 6); - взятие подстроки
String substring = s.replace("Imm", "M"); - замена
String allCapitals = s.toUpperCase(); - преобразование регистра
 Конкатенация - создание новой строки из символов исходных строк
 StringBuilder - объект очень похожий на String, но допускающий изменение содержимого
  Сравнить конкатенация и StringBuilder:
конкатенация String a = "hello"; String b = "world"; String ab = a + b;
StringBuilder sb = new  StringBuilder; sb.append(hello); sb.append(world); String ab = sb.toString();
 Сравнение строк: только не ==, либо s1.equals(s2), либо без учёта регистра s1.equalsIgnoreCase(s2);
	УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ. УСЛОВНЫЕ ОПЕРАТОРЫ 
в if(только boolean true/false) 
 swich(char, String, Enum, целочисленный(int, byte, short, кроме long))
	ЦИКЛЫ
Оператор break прерывает цикл и передаёт управление на следующую за циклом строку
Оператор continue досрочно заканчиват текущую итерацию и начинает следующую
Если много вложенных циклов, то break/continue действуют только на самое глубокое вложение, для воздействия но высшие вложения используют метки outer: {{{{{ break outer}}}}} 
операто return - возврат значения из метки
 	Классы
 объявление класса:
public final class main{}
public - модификатор доступа у класса только public или отсутствует(это значит видимость класса в пределах пакета)
подряд может быть объявлено много классов, но public только оди и его имя совподает с именем класса
final - от нето нельзя наследоваться (относительно других элементов значит что значение этого элемента неизмено)
 состояние члена класса хранится в его полях(переменных членах класса). Поля чаще всего private
Поле константа - static final имя ЗАГЛАВНЫМИ_ЧЕРЕЗ_ПОДЧЁРКИВАНИЯ 
 конструктор - специальный метод вызываемый при создании экземпляра класса (через new). Если параметр конструктора имеет такое же имя как и поле класса, то в конструкторе для доступа к полю класса используется this. . Если в классе нет конструкторов, то автоматически создаётся конструктор без параметров. Если надо запретить создание экземпляров класса, то надо создать private конструктор без параметров.
В классе може быть несколько перегруженных версий конструктора с разными параметрами. Из одиного можно вызывать другой. Задать явные значения для параметров по умолчанию нельзя, но благодаря перегрузке конструкторов это реализуется. 
 Метод
 public void/int/String/... name() { return }
метод исполняется в контексте конкретного экземпляра класса, поэтому может обращаться к полям текущего объекта
может иметь модификатор final - не может переопределятся в классах наследниках
может перегружаться, следовательно и задавать явные значения через перегрузку
static - значит можно вызывать без создания объекта, просто по имени класса
Классы можно вкладывать в классы
 Кроме классов есть интерфейсы, перечисления и аннотации(Объявляются через @ и здесь не разбираем).
  Перечисления enum. Это полноценный ссылочный тип. Его можно рассматривать как класс с фиксированным количеством экземпляров(final полей).
 public enum Name { one, two, other;  fields...,  methods...} 
если после перечисления поставить ; то дальше можно объявлять поля и методы, прнимающий параметры конструктор(но тогда параметры надо передовать каждму перечеслению one(), two(), other().
В перечислениях автоматически доступны методы name, ordinal, статический values. 
name - строка имя элемента перечисления  как в исходном коде
ordinal - число, порядковый номер(с ноля)
values - массив возможных значений перечисления 
 Аннотация @Deprecated - класс устарел и не рекомендуется обычно /** указывают чем заменить */
@SuppressWarnings - временно отключает пердупреждения компилятора на подозрительные места в коде 
	Класс Object.
  Inherite Наследование - создавать класс не с нуля а наследуя или расширяя другие существующие классы
class Child extends Parent {}
Наследоваться можно только от одного класса. Наследник получает все поля и классы родителя. Пользоваться ими может как он сам так и другие программы. Иерархия наследования может быть произвольной(любой) глубины. Вызывать можно а.методыРодителя или а.методыНаследников.
 Методы можно переопределять, т.е. в Наследнике заводить методы с тем же именем и параметрами что и в Родителе. Тип должен совпадать с Родителем или Подклассом(наследником?) и модификатор доступа тот же или более открытый. При этих условиях метод Наследник заменит собой метод Родителя. Рекомендуется ставить #Override пред переопределённым методом
 Создание экземпляра класса Наследника всегда включает в себя инициализацию класса Родителя(вызов его конструктора). Если конструктор без параметров, всё работает само. Если же вызывается конструктор с параметрами, то  в Наследнике первым указывается какие параметры надо передать: super(параметры). Есил вызывается уже переопределённый метод, то super.имяПереопределённогоМетода(параметры). Короч слово super можно использовать только в теле класса Наследника. А иначе всегды вызывается переопределённый в Наследнике метод.
 Object - класс родитель всех классов. Соответственно все классы содержат методы класса Object (их больше десятка, самые популярные: toString(), equals(), hashCode()).
??? хэш код public native int hashCode(); - метод для выяснения хэшкода(по сути нужен только чтобы хранить объекты в хэш таблице)  и хот спот???
	Абстрактные классы.
  public abstract class Name{}
Абстрактный класс - значит нельзя создавать его экземпляры. Но можно создавать экземпляры его классов Наследников(не являющихся абстрактными).
В абстрактном классе может быть всё то же что и в обычном, поля, конструкторы, методы (всё с реализацией, т.к. от него будут наследоваться). Но могут быть и абстрактные методы без реализации(тогда каждый неабстрактный класс наследник должен предоставить реализацию данного метода). 
Не может быть абстрактных методов в неабстрактных классах.
Они решают две задачи: оперделяют набор публичных методов и так же могут содержать неабстрактные поля и методы, какие-то детали реализации.
  Интерфейсы. (служит для объявление контракта объекта по отношению к внешнему миру)
public interface OrderService {
  Orler[] getOrdersByClient(long clientId); }
 Поля могут быть только public static final (константы)  
 Ничего не public быть не может.
 Все методы интерфейса public abstract и эти модификаторы указывать не надо.
 Возможные в интерфейсе исполняющие методы: public static method(), default method().
 Главная фишка! Можно объявлять классы содержащие неограниченное количество интерфейсов. Даже при наличии наследования от класса.
public class B extends A implements C, D, E {}
Примеры интерфейсов:
public interface CharSequence{int length(); char charAt(int i); CharSequence(int start, int end);}//String, StringBuilder
public interface Appendable { Appendable append(CharSequence csq); Appendable append(CharSequence csq, int start, int end); Appendable append(char c);}//StringBuilder  
  Функциональные интерфейсы - интерфейсы с единственным абстрактным методом. Помечаются аннотацией @RunctionalInterface (не обязательн). 
Примеры: 
public interface Runnable { void run();}
public interface Comparator<T> { int compare(T o1, o2);} //o1<02 -; o1==o2 0; 01>02 +.
 Реализацию функциональных интерфейсоы можно заменять лямбда выражениями (но только их). 
//System.currentTimeMillis() возвращает кол-во миллисекунд с 00.00 01.01.1970
//ещё в плсах "получение экземпляра интерфейса при помощи ссылки на метод с подходящей сигнатурой" (Main::method)
	Исключения
  Исключение - это событие, которое случается в процессе работы программы и прерывает стандартрый ход её исполнения, программа переходит в специальный режим поиска обработчика внештатной ситуции, который решит проблему и вернёт программу в штатный режим работы, а если обработчика не нашлось, то JVM звершит работу, но с подробным описанием проблемы. Примеры:
NullPointerException - обращение по нулевой ссылке(null).
ArrayIndexOutOfBoundException - обращение к несуществующему индексу массива.
StringIndexOutOfBoundException - обращение к несуществующему символу в строке.
FileNotFoundException - обращение к несуществующему файлу. Это подкласс:
IOExeption - ошибки ввода/вывода.
После вылета будет распечатано: тип исключения, сообщение с деталями, стектрейс(цепочка вызовов от входа в программу, до метода где произошла ошибка).
 Исключение это объект какого-то класса исключений. 
Все классы исключений наследуются от Throwable(а он от Object). Особенность в том, что они могут быт "брошены": throw new экземплярНовогоИсключения(строка сообщение). только стектрейс покажет где был создан экземплярНовогоИсключения, а не где было вызвано исключение(произошло само "бросание" throw).
 Частые методы класса Throwable:
getMessage() - возвращает текстовую строку с описанием проблемы
printStackTrace() - печатает стектрейс в стандартный поток ошибок
[] getStackTrace() - печатает стектрейс в массив объектов StackTraceElement с именами класса, метода, файла и номер строки.
getCause() - возвращает другое исключение, явившееся причиной данного, либо null.
[] getSuppressed() - создаёт массив исключений.
  Классификация искючений
 -Исключительные ситуации в JVM
  java.lang.Error

 -Исключительные ситуации в пользовательском коде
   -проверяемые (checked)
    java.lang.Exception
   -непроверяемые (unchecked)
    java.lang.RuntimeException

для checked: исключение либо должно обрабатываться в методе, либо в сигнатуре надо указать : public void name() throws IOExeption 
для unchecked таких ограничений нет, "их можно бросать из любой части программы"
 Как можно создавать свои исключения. Как обычный класс, наследующийся от Exeption/RuntimeExeption, содержащий message и cause (если они требуются). Если он unchecked то просто "бросаем", если checked, то его надо указывать в сигнатуре метода и класса/интерфейса в котором он вызывается. При наследовании и реализации интерфейса нельзя декларировать(Объявлять в сигнатуре) переопределённому методу больше исключений чем у базового(Родителя)
  Обработка исключений.
try {блок кода где могут случаться исключения} catch(классИсключения переменнаяКудаСложимИсключенияНаВремяОбработки){код обработчика}
Всё что объявлено в блоке try в блоке catch уже недоступно. Если в блоке try не вылетело исключений, то блок catch не исполняется, а выполняется дальнейший код. Если в блоке try вылетело исключений, то блок catch исполняется, но дальнейший код всёравно выполняется.
Блоков catch может быть несколько(последовательно друг за другом). Тогда они просматриваются в порядке следования и выбирается первый с подходящим типом исключения. Проверка делается с точностью до подкласса(как на instanceof). Выполняется только один catch. C Java 7 можно обрабатывать сразу несколько типов исключений в одном catch, если они не подклассы друг друга, но должны обрабатываться одинаково.
 После catch есть ещё блок finally который выполняется не смотря на try catch (обычно здесь освобождают ресурсы, закрывают файлы, снимают блокировки.   //недостаток - если исключения вылетели и в try и в finally, то первое(ради которого всё делается) мы потеряем. В таком случае либо применяют ещё один try catch в самом finally, либо с Java 7 в try () добавляют как параметры - ресурсы которые будут задействованы и автоматически закрыты(уже без использования finally).
//Оператор instanceof нужен, чтобы проверить, был ли объект, на который ссылается переменная X, создан на основе какого-либо класса Y.
//ресурс - любой объект реализующий интерфейс AutoCloseable (с одним только методом - close)
  Что делать с брошенными и пойманными исключениями. Если на данном этапе программы мы не знаем что с ним делать, то можно пробросить его дальше(тогда и блок try catch не нужен), до того уровня, где будет ясно как его обработать.
//метод проверяющий есть ли что в сроке  или  null. Objects.toString(object) тоже что и String str = object == null ? "null" : object.toString().
    Логирование
  Лог - список приозошедших событий. 
  Класс Логер  
  Набор классов для организации логирования в стандартной библиотеке Java ("Конкуренты" Stdout Stdr). Но тут преимущества(через конфигурационный файл):
-Точечная настройка логирования(вкл/откл на уровне пакетов и классов)
-Настройка уровня детальности логирования
-Настройка места куда логи будут писаться
-Настройка формата ведения логов
import java.util.logging.*;
public class LogDemo{
private static final Logger LOGGER = Logger.getLogger(LogDemo.class.getName()); }
Логи именуют названия пакета + имяКлассаЛогера
первым параметром метод log класса LOGGER принимает уровень логирования Level, говорящий о степени серъёзности данного сообщения с возможными вариантами SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST(для них всех есть одноимённые методы с соответствующими сообщениями).
  Варианты динамической вставки значений х в сообщение:
LOGGER.log(Level.WARNING, "We have a problem! at X" + x);  
LOGGER.log(Level.WARNING, "We have a problem! at X {O}", x);
LOGGER.log(Level.WARNING, "We have a problem! at X ({O}, {1})", new Object[] {x, y});
LOGGER.log(Level.SEVERE, "Unexpected exception", e);
 Обработчик сообщения Handler(абстрактный класс) определяет куда будут записаны сообщения:
-java.util.logging.ConsoleHandler
-java.util.logging.FileHandler
-java.util.logging.SocketHandler
 Обработчик сообщения Formatter (абстрактный класс) определяет формат вывода:
-java.util.logging.SimpleFormatter
-java.util.logging.XMLFormatter
//и Handler и Formatter можно написать свои

	ДОСТУП К ФАЙЛОВОЙ СИСТЕМЕ
java.io.* библиотека отвечающая за ввод/вывод (но есть и в других)
Класс File (java.io.File) отвечает за доступ с файловой системе
 Экземпляры класса File это файлы 
File javaExecutable = new File*("C;\\jdk1.8.0_60\\bin\\java.exe"); 
и директории 
File networkFolder = new File("\\\\server\\share");
// для unix подобных систем File isExecutable = new File(/"usr/bin/ls");
Сборка пути путём конкатенации строк должна содержать разделители в виде File.separator/File.separatorChar (разделитель путей File.pathSeparator/File.pathSeparatorChar это ;/:)
//String a = "src"; String b = "Main.java; String ab = a + File.separator + b;
Либо пусть сам соберёт: File ab = new File(a, b);
  Экземпляр класса File можно создать указав абсолютынй путь ("/usr/bin/java") или относительный ("java").
Проверка на относительный ли путь a.isAbsolute() //true/false
Извлечение абсолютного пути:
a.getAbsolutePath()/getAbsoluteFile() //String/File
String методы для объекта класса File 
a.getPath(); абсолютный путь
a.getName(); имя файла (выдаёт только с расширением)
a.getParent(); весь путь до файла(кроме файла)
a.getParentFile(); весь путь до файла в другой файл.
a.getCanonicalPath()/a.getCanonicalFile; выдаёт истинный путь к файлу. Этот метод уже может выбрасывать IOExeption (надо отлавливать), т.к. при обращении к диску может произойти ошибка ввода/вывода. //пердыдущие метды обращения к диску не требовали
// следующий методы возвращают и true/false
a.exists(); существует ли на диске
 a.isFile(); является ли файлом
методы для файла
a.length(); размер. есил файла нет вернёт 0
a.lastModified(); время последнего изменения с 1970.есил файла нет вернёт 0.
 a.isDirectory(); является и дирикторией
методы для директории
a.list(); выдаст массив строк с её содержимым, если её не существует то null
a.listFiles();  выдаст массив экземпляроа File с её содержимым, если её не существует то null
   Создание нового пустого файла (балавство):
try{ boolean success = file.createNewFile(); } catch (IOExeption e)  { обработка ошибки } //true если всё прошло успешно и false если файл уже существовал.
boolean b = a.mkdir(); Создание директории одного уровня
boolean b = a.mkdir(); создание вложенных директорий
boolean b = a.delete(); удаляет файлы или пусыте директории 
boolean b = a.renameTo(объект типа File);
// нет метода копирования 
   Начиная с Java 7 появился улучшеный класс File:
java.nio.file.Path 
Path path = Paths.get(prj/java");
File FromPath = path.toFile();
Path fromFile = fromPath.toPath();
Объект Path не привязан к файлу на диске, так сказать "строчка обёрнутая набором методов для синтаксических манипуляций"
У класса Path есть все методы что и у File плюс ещё:
a.getNameCount();
a.getName(1); получение компонента пути по его индексу
a.resolveSibling("javap");
a.startsWith("/usr"); является ли один путь префиксом другого
Path.get("/usr").relativize(java); вычисление относительного пути между двумя местами файловой системы
У Path нет доступа к файловой системе, поэтому когда надо залезть на диск, то используются статические методы класса Files
Files.exists(a);
Files.isRegularFile(a);
Files.size(java);
Files.getLastModifiedTime(a).toMillis();
 И копирование
Files.copy(a, Paths.get("/usr/bin/a_copy"), StandardCopyOption.REPLACE_EXISTING); // move тоже есть
 Для директорий - получение содержимого директории:
try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(a)) { 
for {Path child : dirStream) { System.out.println(child); }} // используется try с ресурсами потому, что DirectoryStream<Path> это директория открытая на чтение (ресурс операционной системы, который нужно освобождать)
 Создание директорий
Files.createDirectory(dir);
Files.createDirectories(dir); 
// опять нет метода удаления директории со всем содержимым
	ПОТОКИ БАЙТ
 Ввод данных:
java.io.InputStream - поток байтов из которого можно читать по одному байту или блоками
 Вывод данных:
java.io.OutputStream - поток байтов в который можно писать. 
Оба класса абстрактые. Основные популярные методы InputStream (все throws IOExeption):
read() возвращает следующий байт из входного потока и сдвигается дальше (считывает один байт, но имеет тип int для того чтобы иметь возможность обозначить конец потока). Когда конец достигнут возвращает -1. Если вернулось что-то другое, то фактически считанный байт можно получить явным приведением int к (byte)(фактически взяв младшие 8 бит int)
 Для больших объёмов данных методы читают блоки байтов и записывают их в переданный массив:
read(byte b[]){return read(b, 0, b.length); - принимает только массив байтов и пытается считать из потока кол-во байт равное длинне массива
read(byte b[], int off, int len) - принимает массив байтов, индекс элемента массива начиная с которого этот массив надо начинать заполнять, кол-во байт которое надо считать из входного потока и записать в массив ( возвращает int - количество фактически считанных бай, может быть меньше чем мы просили int len если поток закончился)
skip(long n) пропускает заданное кол-во байт никуда их не сохраняя (возвращает long фактическое кол-во байт которые удалось пропустить, может отличаться от запрошенных long n)
close() закрывает поток и освобождает связанные с ним ресурсы.  
 Основные популярные методы OutputStream (все throws IOExeption):
аналогичные методы для записи байтов по одному или блоками
write(int b) выводит в поток один байт, младшие 8 бит от int b
Для большого объема данных лучше использовать перегруженные:
write(byte b[]){write(b, 0, b.length); берёт всё содержимое массива
write(byte b[], int off, int len); берёт указанное int len кол-во байт начиная с указанного int off индекса в массиве 
flush() сбрасывает возможные промежуточные буфера где могут накапливаться данные перед передачей системе.
close() закрывает поток и освобождает связанные с ним ресурсы, сбрасывает буфера.
 Стримы рекомендуется использовать в блоке try (с ресурсами) чтобы close был гарантированно вызван.
 Чтение Файлов с диска:
InputStream inputSteram = new FileInputStream(new File("in.txt")); принимает либо строку путь либо java.io.File
InputStream inputStream = Files.newInputSteam(Paths.get("in.txt")); для  java.nio.file.Path
 Запись в файл на диск:
OutputStream outputStream = new FileOutputStream(new File("out.txt"));  принимает либо строку путь либо java.io.File
OutputSteam outputStream = Files.newOutputStream(Paths.get("out.txt")); для java.nio.file.Path 
  Чтобы получать поток из сети надо открыть сетевое соединение:
tyr(Socket socket = new Socket("ya.ru", 80) {
 OutputStream outputStream = socket.getOutputSteam();
 outputStream.write("GET / HTTP/1.0\r\n\r\n".getBytes());
 outputStream.flush();

 InputStream inputStream = socket.getIputStream();
 int read = iputStream.read();
 while (rad >= 0) {
  System.out.print((char) read);
  read = inputStream.read();
}}
 
 Работа с донными уже записаными в память виртуальной машины  
 byte[] dsta = {1, 2, 3, 4, 5};
 InputStream inputStream = new ByteArrayInputStream(data);
 ByteArrayOutputStream();
 Byte[] result = outputStream.toByteArray();

Полезный класс DataOutputStream оборачивает OutputStream и даёт возможность работать уже не с байтами а примитивнымиТипами/строками writeInt(int a)/writeUTF 
Так же и DataInputStream оборачивает InputStream и позволяет работать с примитивнымиТипами/строками readInt()

DeflaterOutputStream(os) - реализует сжатие записываемых данных по алгоритму дефлэйтер
InflaterOutputStream - распаковывает
// закрытие одного стрима вызывает закрытие всех. Достаточно одного close().

	Работа с текстом в потоках ввода/вывода
  Ввод данных
java.io.Reader
методы: 
read(); возвращает int но смотреть надо на 2(а не 1 как с с потоком байт) младших байта.
read(char cbuf[]){return(cbuf, 0, cbuf.length); принимают массивы символов, остальное как с байтами
read(char cbuf[], int off, ijnt len); принимают массивы символов, остальное как с байтами
skip(long n);
  Вывод данных
java.io.Writer аналогичен outputStream только с заменой байтов на char
методы:
write(int c);
write(char cbuf[]){write(cbuf, 0, cbuj.length)};
write(char cbuf[], int off, int len);
  Можно превратить произвольный поток байтов в поток символов, завернув его в InputStreamReader или в OutputStreamWriter. 
Read reader = new InputStreamReader(inputStream, "UTF-8");
Cahrset charset = StandsrdCharsets.UTF_8;
Write writer = new OutputStreamWriter(outputStream, charset);
Обязательно указывать кодировку. Либо как строку "UTF-8", либо ка объект типа charset.
 java.nio.charset; Charset можно получить либо так: Charset.forName("...");(можно получить болише кодировок, но нет гарантий переносимости кода) либо Cahrset charset = StandsrdCharsets.UTF_8;(но кодировки только: UTF-8, UTF-16, ASCI). Если кодировку в конструктор не передавать, то будет использована системная кодировка по-умолчанию, на неё лучше не полагаться. Узнать её можно Charset.defaultCharset().
  Для чтения и записи текстовых файлов есть классы 
FileReader и FileWriter.
Reader neader = new FileReader("in.txt");
Writer writer = new FileWriter("out.txt");
Но в них нельзя указать кодировку, поэтому при работе с файлами кодирвока которых нам известна используют вот такие конструкции:
Reader reader2 = new InputStreamReader( new Jile InputStream("in.txt"), StandardCharses.UTF_8);
Writer writer2 = new OutputStreamWriter( new FileOutputStream("out.txt"). StandardCharsets.UTF_8); 
Классы:
Reader reader = new CharArrayReader( new char[] {'a', 'b', 'c'}); чтение символов из массива
Reader reader2 = new StringReader("Hello World!"); чтение строки из памяти.
 CharArrayWriter write = new CharArrayWriter(); //удобно использовать для тестирования кода
wirter.write("Test");
char[] resultArray = writer.toCharArray();
 StringWriter writer2 = new StringWriter(); // удобно использовать для тестирования кода
writer2.writer("Test");
Stirng resultString = writer2.toString();
   Класс BufferedReader c методами 
BufferedReader(Reader in) который оборачивает произвольный Reader и добавляет к нему буферизацию, даже если  обрабатывает по доному символу, всёравно запрашивает большой объём данных и хранит их в буфере,
String readLine() - читает из потока целую строку до ближайшего символа конца строки(сам символ разделяющий строки не возвращается). Если дочитали до конца строки и поток закончился, то возвращается null.
  Чтобы построчно прочитать и обработать файл:
try (BufferedReader reader = Files.newBufferedReader(Paths.get("in.txt"), standardCharsets.UTF_8)) { string line; while ((line = reader.readLine()) != null){}};
 Для небольшого файла можно проще(вернуть сразу все строки в виде списка:
List<String> lines = Files.readAllLines(Paths.get("in.txt"), StandardCharsets.UTF_8); for (String line : lines) {};
 Аналогично с чтением приоисходит запись:
try (BufferedWriter writer = Files.newBufferedWriter( Path.get("out.txt"), StandardCharsets.UTF_8)){ writer.write("hello");; writer.newLine();} копит в буфер большие куски данных и сбрасывает их в оборачиваемый райтер. newLine - разделитель строк.
Для небольшого файла метод принимает список строк и преврацает его в текстовый файл:
List<String> lines = Arrays.asList("Hello", "world");
Files,write(Paths.get("out.txt"), lines, StandardCharsets.UTF_8);  
       Форматированный ввод/вывод значений разных типов (конвертация) реализован как ндстройка над ридерам и райтером.
  Вывод //объекты преобразуются в строки при помощи метода toString().
package java.io;
pbulic class PrintWriter extends Writer {
 public PrintWriter(Writer out){} //все полученные данные конвертирутся в строки и передаются классу Writer для вывода
 public void print(int i){}
 public void printLn(Object obj){} // принимает любой объект
 public PrintWriter pringf(String format, Object ... args){} принимает строку шаблон format  и набор параметров которые будут подставляться в эту строку args. (места подстановки обозначаются специальными символами %s-место строки %d-целого числа %.3f-вещественного числа округлённого до 3 цифр после запятой. 
Эти методы не бросают IOExeption, а устанавливают внутренний флаг ошибки, чтобы его проверить:
 public boolean checkError(){}
Класс PrintStream пердоставляет те же методы что и PrintWriter, только оборачивает не Writer а OutputStream.(и сам им является). Внутри методов print он сначала преобразует из примитивных методов в строку, а потом сразу в байты, которые передаются нижележащему OutputStream для вывода (гибрид OutputStream и PrintWriter)
java.io.streamTokenizer
StreamNokenize a = newStreamTokenizer(new StringReade("Hi")); умеет рабзирать поток на слова и числа
java.util.StringTokenizer
StringTokenizer b = new StringTokenizer("hi"); читает из строки 
Эти два класса устарели, вот их современный потомок Scanner scr = new Scanner(reader/другие)
.useDelimiter("\\|"); устанавливаем свой разделитель для нарезания входного потока на токены(по-умолчанию пробел)
.useLocale(Locale.forLanguageTag("ru")); региональные настройки, особенности языка
В нём можно парсить
String token = scr.next();
boolean bool = scr.nextBoolean();
double dbl = scr.nextDouble();
int integer = scr.nextInt();

Для общего сведения:
Класс ProcessBuilder отвечает за запуск внешних процессов
ProcessBuilder a = new ProcessBuilder();
a.command("ls", "-l"); указываем запускаемую команду
a.derectiry(new File("/home/jk/"); указываем рабочую директорию, в которой будет запускаться новый процесс
a.redirectInput(Redirect.from(new File("/dev/null"))); подключение потока ввода в процесс. Перенаправить поток в файл или из файла.
a.redirectOutput(Redirect.PIPE); направление потока вывода PIPE - полное получение стрима и прямая работа с ним из java
a.redirectError(Redirect.INHERIT); направление потока ошибок INHERIT- унаследовать поток java процесса(забрать данные из stdr процесса в stdr java) 
Process b = a.stаrt(); стартуем новый процесс. Далее работа с PIPE
try (BufferedReader c = new BufferedReader(new InputStreamReader(b.getInputStream()))){c.lines().forEach(System.out::println);} принимаем всё что выводит поток внешнего процесса и записываем в поток стандартного вывода java процесса(ручная реализация INHERIT)
int exitValue = b.waitFor(); ожидание окончания дочернего процесса и получение его кода возврата.(0 - успех)
if(exitValue != 0) {
System.out.print("aborted");}}}  
   Методы read/write InputStream/OutputStream - блокирующие, программа останавливается пока не получит данные(хотябы 1 байт)/пока всё не запишет. НЕ блокирующие аналоги более низкоуровневые java.nio.channels.*; java.nio.ByteBuffer; "можно из одного треда работать сразу со многими каналами (при калссическом io, на каждый канал нужен свой тред)
   Сериализация - взять из памяти объект, превратить его в набор байтов(вместе со всеми значениями его полей), сделать с ним что угодно(например записать в файл, передать по сети, там декодировать и получить такой же точно объект. 
Класс должен implements Serializable Это маркерный интерфейс(т.е. в неём не объявлено ни одного метода). Поля помеченые transient не будут сериализовываться. Для десериализации предназначен класс ObjectInputStream и его метод readObject()	

		GENERICS
Параметризованные типы. <T>
Значением параметра не может быть примитивный тип или примитивное значение, только ссылочные типы.
public static <T extends Comparable<T>> T minElement(T[] values) {... T min = values[0]; ...} // вместо T будет подставлен любой тип удовлетворяющий условиям extends Comparable<T>
 Класс из стандартной библиотеки java.util;(мини контейнер для одного объекта любого типа) :
puublic final Class Optional<T> {}
он нужен для того, что бы не делать постоянно проверку на null(можно @Nullable, @NonNull, но из сторонних библиотек, не годных для компилятора и его проверок). Как решение:
String text = "bar"; - обычная ссылка
Optional<String> oprionalText = Optional.of("baz:); -потенциально отсутствующая ссылка
вот это:
baz.ifPresent(System.out::println); значит это:
if(s!=null){System.out.println(s);}; // s - обычная переменная String
а это:
String value = bar.orElse("bar"); значит это:
s!=null?s:"bar";
 при наследовании extends используется и для классов и для интерфейсов, перечисляются через амперсанд.
public final class Optional<T extends One & Two & Three>
теперь Т можно использовать в любом месте где и обычное имя типа. Т заданный на уровне класса используется для параметризации эеземпляров, поэтому недоступен в статических полях и методах.
Для статических Т указывается после модификаторов и перед именем возвращаемого типа и не является тем же Т что и указанный после имени возвращаемого типа:
public static <T> Opional <T> of(T value){}
 С классом Optional можно (у этого метода конструктор приватный, экземпляры должны создаваться через статические фабричные методы):
Optional<String> foo = Optional.empty(); возвращае пустой Optional не содержащий ссылку на объект, подгоняет возвращаемое значение к нужному типу.
Optional<String> bar = Optional.of("bar"); возвращает Optional(в данном случае String) содержащий указанный объект(аргумент не может быть null.
Optional<String> baz = Optional.ofNullable("baz"); возвращает Optional(в данном случае String) содержащий указанный объект, если там null, то пустой Optional(в данном случае String).
 Чтобы из Optional параметризованным String получить Optional параметризованный CharSequence надо это явно указать .<явное приведение типов>   
Optional<CharSequence> optionalCharSequence = Optional.<CharSequence>ofNullable("baz");
Optional<String> newOptional = new Optional<>("foobar"); <> дайманд оператор, при использовании new компилятор сам поймёт что подставлять. 
 При использовании параметризованных типов компилятор не создаёт методы для каждого инстанцированного параметра. Будет один класс в котором вместо <T> будет Object.
И уже в процессе испольнения программы компилятор колдует в местах использования различных параметризаций этого класса(например производит неявное приведение типов). Если не использовать(указывать) <T> то тогда везде будет использоваться Object.
 Ограничения: внутри параметризованного класса или метода нельзя создавать экземпляр Т или массив Т; не работает проверка instanceof; приведение типа T a = (T) b выполниться, но не произведёт проверок на правильнось выполнения.
 Для использования Наследников или Родителей класса T надо использовать запись <? super T> для использования Т и его родителей и <? extends T> для использования Т и его наследников. // правило если получать объекты, то ?extends, если передавать, то ?super.
<?> принимает любое значение, через .get возвращает Object. а вызвать метод принимающий это значение вообще не выйдет, компилятор не видит тип.

		Коллекции.
 Недостатки массива: фиксированный размер; нет защиты от изменеий(если доступуен для чтения, то и для записи)
Коллекции легко изменяемы по размеру(просто втавлять и удалять элементы); могут разрешать чтение, но не изменение; много удобных методов.
Коллекции - genericи и параметризуются типом хранимых внутри элементов, следовательно коллекции работают только со ссылочными типами. Чтобы хранить примитивные типы : можно использовать классы обёрткию; можно вручную написать класс похожий на коллекцию, но хранящий примитивы; можно использовать класс из сторонней библиотеки.(два последних напряг).
java.util; тут коллекции
java.util.concurrent; тут коллекции для многопоточных программ.
 Основные классы-коллекции. (Абстрактная) 
public iterface Collertion<E> extends Iterable<E> { //Самый основной
int size(); текущий размер коллекции
boolean isEmpty(); проверка пустоты
boolean contains(Object o); пороверка принадлежности объекта к коллекции
boolean add(E e); добавление элемента в коллекцию
boolean remove(Object o); удаление элемента из коллекции
void clear(); удаление всех элементов из коллекции
}
contains, add, remove используют equals
У коллекций есть метод iterator() унаследованный от java.util.Iterable и возвращающий экземпляр Iterator<Integer>. Он позволяе единообразно обходить элементы любой коллекции. У него есть три метода
.hasNext() проверна наличия следующего элемента
.next() получение найденного следующего элемента
.remove() удаление текущего элемента из коллекциию(текущий это последний возвращённый из next())
  Варианты обхода:
Collection<Integer> collection = ...;

Iterator<Integetr> it = collection.iterator();
while(it.hasNext()) {
Integer element = it.next();
System.out.println(element);}

for(Integer element : collection){
System.out.println(element);}

collection.forEach(System.out::println);(в качестве параметра принимается экземпляр java.util.function.consumer<T> c единственным методом accept(T). используем возможность инстанцировать функциональный интерфейс при помощи ссылки на метод
 
Сокращённые записи не позволяют удалять элементы во время обхода.

Классы нследники:
public iterface List<E> extends Collection<E> {
E get(int index); получение элемента по индексу
E set(int index, E element); замена элемента по индексу
void add(int index, E element); добавление элемента по индексу. (с index сдвигаются вправо на 1 позицию, впуская новый элемент)(add унаследованый от коллекции возвращает элемент в конец списка.
E remove(int index); удаляет элемент по индексу(и возвращает его)
int indexOf(Object o); ищет элемент в списке и возвраащет его индекс первый сначала (не нашёл -1)
int lastIndex0f(Object o); ищет элемент в списке и возвраащет его индекс первый с конца (не нашёл -1)
List<E> subList(int fromIndex, int toIndex); возвращает часть списка в виде отдельного экземпляра List(не копирование, изменение в одном списке будут видны в другом)
  Распросранеённые реализации List:
List<String> list1 = new ArrayList<>();
List поверх массива, даёт максимально дешёвый доступ к элементу по индексу.
List<Integer> list2 = new LinkedList<>();
Основанно на двусвязном списке. Позволяет эффективно добовлять или удалять элементы в начале или в конце списка.

   Вторая разновидность коллекций:
Очередь(первый вошёл, первый вышел) //Queue (FIFO)
public iterface Queue<E> extends Collection<E>{
boolean add(E e); добавляет элемент, если очередь достигла предела то thorows exeption
boolean offer(E e); добавляет элемент, если очередь достигла предела то возвращает false
E remove(); извлекает первый элемент, если очередь пуста то throws...
E poll(); извлекает первый элемент, если очередь пуста то null
E element(); позволяет посмотреть элемент не удаляя его(throws...)
E peek(); позволяет посмотреть элемент не удаляя его(null)
}
Элементы добавляются с хвоста  и извлекаются из головы
 Наследник позволяющий добавлять и удалять элементы как с хвоста так и с головы:
public interface Deque<E> extends Queue<E>{
void addFirst(E e); 
void addLast(E e);
boolean offerFirst(E e);
boolean offerLast(E e);
E removeFirst();
E removeLast();
}
 Реализации Deque:
Deque<Object> d1 = new ArrayDeque<>();
Deque<Integer> d2 = new LinkedList<>(); 

  Третья разновидность множесто (уникальных) не может содержать два элемента равные друг другу
public iterface Set<E> extends Collection<E>{} //методы как и в Collection
.add(дубликат) вернёт false
Реализации интерфейса Set:
Релизация множества на основе Хэш таблицы(использует hashCode() для определения куда положить объект, equals()для сравнения с уже лежащими в таблице элементами)(a.equals(b) ти и a.hashCode()==b.hashCode();
Set<ComplexNumber> numbers = new HashSet<>(); 
numbers.add(new ComplexNumber(3, 3));
nubmers.remove(new <ComplexNumber(3, 3));
Элемент недолжен меняться пока лежит в таблице.
LinkedHashSet<>(); отличается от HashSet(); тем, что запоминает последоватьельность добавления элементов.

  Упорядоченное множество(поэтому итератор проходит в порядке возрастания элементов)
public iterface SortedSet<E> extends Set<E> {
SortedSet<E> subSet( E fromElement, E to Element);
SortedSet<E> headSet(E toElement); возвращает подмножество элементов, меньше чем переданный параметр.(не копия)
SortedSet<E> tailSet(E fromElement);
E first();
E last();
}
Реализация:
SortedSet<String> words = new TreeSet<>();
 
	Четвёртое множество мапа(отображение или ассоциативный массив) представленный интерфейсом java.util.Map;(Не относится к Collection но схож по идеологии)
Элементны индексируются произвольными объектами(а не цифрами как в массиве)
public interface Map<K, V> {
int size(); размер(количество пар ключ-значение хранящихся в данный момент)
boolean isEmpty(); проверка пустоты
boolean containsKey(Object key); проверяет есть ли в мапе сейчас такой ключ
boolean containsValue(Object value); проверяет есть ли сейчас такое значение
V get(Object key); получает значение по ключу
V put (K key, V Value); сохраняет значение по ключу // возвращает значение которое было по задонному ключу в начале запрошенной операции
V remove(Object key); удаляет пару ключ-значение с заданным ключом // возвращает значение которое было по задонному ключу в начале запрошенной операции
void clear(); полностью очищает мапу
Обход всего содержимого:
Если нужны только ключи:
Set<K> keySet(); вернёт множество ключей(дубликаты ключей в мапе недопускаются)
Если нужны только значения:
Collection<V> values(); вернёт коллекцию значений(т.к. про уникальность значений ничего не известно)
Если нужны и ключи и значения:
Set<Map.Entry<K, V>> entrySet(); вернёт множество объектов Entry<K, V> содержащих ключ-значение.
 Примеры использования этих методов:
Map<A, B> map = new HashMap<>();
for (A key : map.keySet()){} обход ключей
for (B value : map.valies()) {} обход значений
for (Map.Entry<A, B> entry : map.entrySet()){
  System.out.printf("%s => %s\n", entry.getKey(), entry.getValue()); } обход пар ключ-значение
map.forEach((k, v) -> System.out.printf("%s => %s\n, k, v)); принимает экземпляр java.util.function.BiConsumer<T, U>:(это функциональный интерфейс с методом) accept(T, U) (с двумя параметрами которым мы передаём лямбда выражение)
 Реализация интерфейса мап:
Map<String, String> map1 = new HashMap<>()/LinkedHashMap<>();
map1.put("foo", "baz");
map1.put("bar", "baz");
map1.remove("bar");
SortedMap<String, String> map2 = new TreeMap<>();
map2.put("foo", "bar");
map2.put("bar", "baz");
map2.subMap("bar", "foo").clear();
 Устаревшие классы java.util.Vector/Stack/Dictionary/Hashtable оставленные лишь для обратной совместимости
  В работе с коллекциями помогает утилитный класс java.util.Collections; в котором есть методы
Collections.shuffle(list); перемешивание
Collections.sort(list); сортировка
Set<String> set = Collections.unmodifiableSet(originalSet);//unmodifiableList(), unmodifiableMap(); эти методы возвращают объект-обёртку, реализующую тот же интерфейс, что и переданный параметр и предоставляющий доступ на чтение к элементам исходной коллекции.
Но попытка изменить содержимое коллекции через этот объект-обёртку set.remove("abc"); выбросит исключение UnsupportedOperationException.
Для конвертации коллекций в массив:
List<Integer> list = ...;
Object[] ar1 = list.toArray(); возвращает содержимое коллекции в виде маасива Objecto[] (т.к. дженерики не позволяют создать массив <Integer>)
Integer[] ar2 = list.toArray(new Integer[list.size()]); а здесь всёже получаем массв Integer[].
 Обратная конвертация из массива в коллекцию:
String[] array = {"A", "B", "C"};
Set<String> set1 = new HashSet<>(Arrays.asList(array)); превращаем массив в список ипередаём его конструктору класса-коллекции
 Set<String> set2 = new HashSet<>(); создаём пустую коллекцию и прередаём в неё все элементы из массива при помощи утилитного метода Collections.addAll(set2, array);
//Коллекции могут содержать только объекты, а массивы могут содержать и примитивы.

Коллекции можно сравнивать по содержимому обычным методом equals(), а для сравнения массивов используется внешний утилитный метод Arrays.equals().

Массивы встроены в язык, а коллекции — обычные классы стандартной библиотеки.

Коллекции могут динамически менять размер, а размер массива фиксируется при создании. //

	Функциональный интерфейс (с java8) 
Интерфейс в котором только один метод(default и static методы, static поля не в счёт, их может быть сколько угодно) компактный кусок кода в качестве параметра в другой код
испоьлзовать компактные лямбда выражения и ссылки на методы. что позволяет писать программы в функциональном стиле (последовательное применение функций к некоторым значениям и другим функциям)(а не сложная структура из циклов, условных операторов и перекладывания значений переменных)
@FunctionalEnterface
public interface FileFilter
java.util.function содержит более сорока стандартных интерфейсов. Они делятся на 5 семейств:
1 Consumer<T> {void accept(T t);} "Потребители" принимают значения но ничего не возвращают взамен. Для примитивов есть IntConsumer, LongConsumer, DoubleConsumer.(опять же потому что дженерики не могут параметризаваться примитивными типами).
Так же есть Consumerы принимающие по два параметра. Один из них BiConsumer<T, U> с методом void accept(T, U) принимающим два параметра и ничего не возвращающем.
2 Supplier<T> {T get();} "Поставщики" они ничего не принимают в качестве параметра, только возвращают каое-то значение. Так же есть BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier.
3 Predicate<T> {boolean test(T t);} "Предикаты" принимает значение какого-либо типа и возвращает boolean true/false. Есть так же IntPredicate, LongPredicate, DoublePredicate и принимающий сразу два параметра "бинарный предикат" BiPredicate<T, U>  
4 Function<T, R> {R apply(T t);} "Функции" принимают аргумент и возвращают значения какого-то типа. Есть функции принимающие два параметра BiFunction. Так же есть масса специализаций функций принимающих на место одного или обоих параметров примитивы. Например DoubleFunction принимающая dobule и возвращающая объект Т, или LongToIntFunction принимает long и возвращает int. ToIntFunction принимает объект Т и возвращающая int. И много других.
5 UnaryOperator<T> extends Function<T, T>{} "Операторы" (частный случай функции) когда на входе и на выходе значения одного и того же типа. BinaryOperator принимает два параметра. Так же Unary/BinaryOperator заведены для Int, Long, Double. 
   Функциональные интерфейсы можно инстанцировать тремя способами:
Можно завести именнованый или анонимный класс реализующий интерфейс.
class IntSquare implements IntUnaryOperator{
 public int applyAsInt(int operand){
  return operand * operand;
}}

Можно использовать лямбда выражения:
IntUnaryOperator square = x -> { //компилятору достаточно имени интерфейса, поэтому не нужны имяМетода, типы параметров и т. д.
 return x * x; // нужны только имена параметров и тело метода(код)
};
IntConsumer print = x -> System.out.print(x); если тело метода состоит из единственного метода (и это не return), то {}можно опустить
IntUnaryOperator cube = x-> x * x * x; а если это был return, то вместе со скобками удаляем и это слово.

 К каким переменным и как можно обращаться в теле метода.

public class Demo{
 private int counter;
 public void foo() {
  IntUnaryOperator square = x -> x * x; //К параметрам лямбды. Объявлять и использовать внутри тела лямбда выражения лбые переменные 
 IntSupplier sequence = () -> counter++; //к полям того класса внутри которого объявлена лямбда. Их можно и читать и писать.
  int bonus = 10;
  IntUnaryOperator bonusAdder = (x) -> x + bonus;}} // к переменным созданным внутри того метода где объявлена лямбда. Но только эти переменные должны быть эффективно-финальными(т.е. значение им должно быть присвоено ровно один раз до создания лямбды, после меняться оно уже не может.
Из лямбды нельзя присваивать новые значения переменным содержащего её метода. Для обхода этого ограничения используют трюк с массивом одиночной длинны.
int[] counter = new int[] {0};
IntSupplier sequence = () -> counter[0]++; //т.е. ссылка на массив является эффективно-финальной, но на содержимое это ограничение не распространяется
В третих можно инстанцировать при помощи ссылки на метод:
ToIntFunction<String> intParser = Integer::parseInt; ссылка на статический метод ИмяКласса::СтатическийМетод
Consumer<Object> printer = System.out:: println; ссылка на нестатический метод КонкретныйОбъект::ИмяНестатического метода
Function<Object, String> objectToString = Object::toString; ещё ссылка на нестатический метод ИмяКласса::ИмяНестатическогоМетода. Тогда ИмяКласса должно быть передано первым параметром функционального интерфейса
IntFunction<String[]> arrayAllocator = String[]::new; ссылка на конструктор ИмяКласса::new;

Интересные и полезные default и static методы
метод получающий обратный предикату .negate();
коньюнкция двух предикатов a1.and(a2);
комбинация двух консьюмеров в третий a1.andThen(a2); вызывает сначала первое действие потом второе.
для композиций функций a1.andThen(a2) и a1.compose(a2) разница в порядке применения a1a2 и a2a1
Comporator.comparing(Math::abs, Double::compare) Math::abs будет применяться к каждому значению перед тем как выполняется сравнение, а Double::compare будет сравнивать результаты применение первого метода к исходным значениям чтобы получить финальный результат

		Stream API	
Stream(поток) - последоватьельность элементов потенциально бесконечаная с возможностью применять к ней простые и сложные(многоэтапные преобразования) без использования циклов и условных операторов.
java.util.stream:
public interface Stream<T> externds BaseStream<T, Stream<T>>{} // так же есть IntStream, LongStream, DoubleStream
Итератор простой объект который умеет выдавать элементы по одному, в отличие от него у стрима огромное количество методов. 
Итератор - средство обхода элементов
Stream - средство описания алгоритма обработки и преобразования последовательностей элементов.
 В сравнении с коллекциями
Коллекции подразумевают конечное хранение набора элементов
Stream - потенциально бесконечен
Коллекции часто предоставляют индивидуальный доступ к элементам
Stream такого не позволяет
Коллекции можно менять добовлять/удалять
Stream и применимые к нему трансформации не влияют на источник элементов
 Примеры:
int sum = IntStream.iterate(1, n->n+1) //(первыйЭлПоследовательности, функцияВычисленияСледующегоЭлементаПоследовательности по предыдущему) Возвращает  IntStream бесконечную последовательность целых чисел 
Дальнейшие методы преобразовывают IntStream и возвращают преобразованный Stream
.filter(n->n%5==0&&n%2!=0) фильтруем, оставляем только те, что делятся на 5 и не делятся на 2
.limit(10) из бесконечной последовательности берём только 10 первых
.map(n->n*n) возводим каждый из элементов в квадрат
.sum(); суммируем и получаем результат
 Использование Stream всегда состои из трёх этапов:
1 IntStream.iterate(1, n->n+1) получение стрима, откуда будут браться элементы последовательности
2 .filter(n->n%5==0&&n%2!=0), .limit(10), .map(n->n*n) это 0 или более промежуточных операций преобразования. Стрим их запоминает но не спешит выполнять
3 .sum(); это единственная терминальная операция, запускающая весь процесс вычислений и должна стать полезным результатом
4 .close() опциональный заключительный шаг - закрытие стрима. Но он обязателен только если стрим выделял какие-то ресурсы(связан с содержимым класса или директорией на диске). Можно использовать в блоке try(с ресурсами), т.к. стрим реализует интерфейс autocosable
 
 Этапы работы со Stream подробнее:
 Порождение стрима(откуда можно взять):
Set<String> vocabulary = ...;
Stream<String> stream1 = vocabulary.stream(); из любой коллекции с помощью метода .stream()
BufferedReader reader = ...;
Stream<String> stream2 = reader.lines(); из BufferedReaderа с помощью .lines();, который вернёт поток строк из данного потока символов.
Path path = ...;
Stream<Path> stream3 = Files.list(path); из директории на диске, вернёт содержимое директоии на один уровент
Stream<Path> stream4 = Files.walk(path); из директории на диске рекурсивно обойдёт и поддиректории
IntStream chars = "hello".chars(); будет содержать символы строки(получим IntStream т.к. в стандартной библиотеке нет  CharStream )  
 Стримы можно порождать динамически:
DoubleStream rand = DoubleStream.generate(Math::random); генерировать при помощи суплаера (поставщика). Supplier - интерфейс с единственным методом методом get, который должен последовательно возвращать элементы. 
IntStream integers = IntStream.iterate(0, n-> n+1); итерированием функции
IntStream smallIntegers = IntStream.range(0, 100); диапазон целых чисел в виде стрима. Вернёт 0...99
IntStream smallIntegers2 = IntStream.rangeCloosed(0, 100); диапазон целых чисел в виде стрима. Вернёт 0...100
IntStream comb = IntStream.concat(stream1, stream2); конкатенацией двух других стримов.
IntStream empty = IntStream.empty(); взять пустой стрим
double[] array = ...;
DoubleStream streamFromArray = Array.stream(array); получить стрим из массива
IntStream streamOfElements = IntStream.of(2, 4, 6, 8, 10); явно перечислить элементы стрима

  Промежуточные операции:
IntStream stream = ...;
stream.filter(n -> n > 100) фильтрация принимает предикат, последовательность будет из элементов удовлетвоярющие предикату
 .mapToObj(Integer::toString) мэп принимает функцию, которая из каждого элемента стрима делает новый элемент, потенциально другого типа(конкретно здесь мы каждое число конвертируем в строку)
 .flatMapToInt(s -> s.chars()) принимает функцию возвращающую Стрим(здесь возвращает стрим символов) Сначала каждый элемент преобразует в отдельный стрим, а потом конкатенирует все эти стримы в один.
 .distinct() убирает из стрима дубликаты
 .sorted() преобразует стрим, выстраивая элементы по порядку по возростанию(если стрим состоит из объектов, то туда можно передать компоратор) 
 .skip(3) пропустить n первых элементов
 .limit(2); ограничивает оставшиеся элементы заданным количеством
 .peek(Consumer) позволяет подсмотреть какие элементы летают на разных этапах обработки. Для отладки в Consumer удобно передавать System.out::println

  Терминальные операции(производят каой-то полезный результат):
 Запускает стрим на исполнение
IntStream stream1 = ...; 
sterm1.forEach(System.out::println); принимает Consumer, которому будут отданы все элементны, которые остались в стриме(здесь будут выведены в консоль)
IntStream stream2 = ...;
OptionalInt result = stream2.findFirst(); возвращает первый в порядке следования элемент из стрима (возвращает OptionalInt, т.к. стрим может оказаться пустым)/findAny() вернёт не первый, а тот который удобнее стриму 
Stream<String> stream3 = ...;
boolean allStringsAreAtLeast10Chars = stream3.allMatch(s -> s.length() > 10); проверка что все элементы стрима удовлетворяют переданному условию предикату/ anyMatch хоть один / noneMatchне один
Stream<String> stream1 = ...;
Optional<String> minString = stream1.min( Comparator.comparing(Sring::length, Integer::compare)); минимальное занчение стрима(Optional т.к. стрим может быть пустой) /max (Здесь Сomporator правио по которому определяется мин и макс)
IntStream stream2 = ...;
int count = stream2.count(); просто количество элементов оставшихся в стриме после применения всех трансформаций и фильтраций
IntStream stream3 = ...;
int sum = stram3.sum();	 сумма элементов
Stream<String> stream1 = ...;
List<String> list = stream1.collect(Collectors.toList()); позволяет собрать элементы стрима в новое хранилище(здесь в список), тип этого хранилища определяется параметром передаваемым в .collect()(Класс Collectors содержит много стандартных коллекторов) 
Steam<BigInteger> big = ...;
BigInteger sum = big.reduce(BigInteger.ZERO, BigInteger::add); позволяет вычислить свёртку элементов стрима, т.е. результат применения некоторого бинарного оператора к каждой паре элементов стрима, пока от стрима не останется один единственный элемент
	
   На стриме терминатльную операцию можно вызвать только один раз. После стрим не пригоден к использованию, дальше надо заново конструировать, настраивать и запусткать

	Алгоритмы при помощи стримов. Примеры:
 факториал числа n
public static BigInteger factorial(int n) {
 return IntStream.rangeClosed(1, n) порождаем интервал целых чисел от 1 до n в виде стрима
  .mapToObj(i -> BigInteger.valueOf(i)) каждое число превращаем в BigInteger 
  .reduce(BgInteger.ONE, BigInteger::multiply);} вычисляем свёртку операцией умножения

 определение того, что строка является полиндромом:
public static boolean isPalindrome(String s){
 StringBuilder leftToRight = new StringBuilder();
 s.chars().filter(Character::isLetterOrDigit)
  .map(Character::toLowerCase)
  .forEach(leftToRight::appendCodePoint);
 StringBuilder rightToLeft = new StringBuilder(leftToRight).reverse();
 return leftToRight.toString()
  .equals(rightToLeft.toString()); }
