А ещё JDK также содержит компилятор javac, который преобразует исходный код Java в байт-код, а также другие инструменты, такие как отладчик (javadebug), профилировщик (javaprobe) и другие утилиты разработки. Именно JDK используется программистами для создания и сборки Java-приложений.
Только для целых чисел int и long, поддерживается остаток от деления:

Чтобы понять, каким числом станет результат переполнения
byte x = -128; x -= 2; 
нужно прибавить 256 к результату.
-130 + 256 = 126.

В отличие от целых чисел, деление значений с плавающей запятой на ноль никаких исключений не вызывает. Арифметика чисел с плавающей запятой реализована в соответствии со стандартом IEEE 754, который требует возвращения специального значения «Infinity» (Бесконечность), когда положительное число делится на ноль.
float real = 0.0f/0.0f; if (real == real)
Переменная real не равна самой себе. Как такое возможно? Арифметика с плавающей запятой реализована в соответствии со стандартом IEEE 754, который требует возвращения специального значения «NaN» (от английского “Not a Number” – не число), когда ноль делится на ноль. В спецификации также указано, что NaN не равно никакому значению с плавающей запятой, включая само себя.

Поскольку строки неизменяемы в Java, для увеличения эффективности производительности и экономии памяти используется интернирование строк (string interning). Интернирование строк – это метод, при котором сохраняется только одна копия каждого различного строкового значения. Следовательно, обе ссылки (str1 и str2) указывают на одну и ту же ячейку памяти.

Динамический полиморфизм не используется при вызове статических методов. те A var = new B(); var.print(); вызовет метод из А(не В как у не статических)

Вызов нестатических методов из статических функций запрещен, поскольку нестатические методы связаны с экземплярами класса.

Java не запрещает перегрузку функции main. Но имеющая String[] в качестве аргумента функция main всегда служит точкой входа в программу.

В Java аргументы переменной длины (varargs) должны быть последними.

ava разрешает вызывать статические методы на null.

 В Java не допускается перехват исключения базового класса перед исключением производного класса.


rozel.jeka@gmail.com	
workingman01	
@1q2w3e4r5!
112000

Инструкции (statement) - основной строительный блок программы. Каждая инструкция выполняет некоторое действие, например, вызовы методов, объявление переменных и присвоение им значений. После завершения инструкции в Java ставится точка с запятой (;) что указывает компилятору на конец инструкции.
Так же распространенной конструкцией является блок кода. Он содержит набор инструкций, заключается в фигурные скобки, внутри которых помещаются инструкции.

Переменные предназначены для хранения данных в программе. Переменная представляет именованную область памяти, которая хранит значение определенного типа. Каждая переменная имеет тип, имя и значение. 
Именя переменной - любое произвольное название, которое удовлетворяет требованиям:
- имя может содержать любые алфавитно-цифровые символы, а также знак подчеркивания, при этом первый символ в имени не должен быть цифрой
- в имени не должно быть знаков пунктуации и пробелов
- имя не может быть ключевым словом языка Java

int x;      // объявление переменной
x = 10;     // присвоение значения
Инициализация - присвоить значение переменной при ее объявлении.
int x = 10;     // объявление и инициализация переменной
Через запятую можно объявить сразу несколько переменных одного типа:
int x, y; или сразу инициализировать: int x = 8, y = 15;
Отличительной особенностью переменных является то, что мы можем в процессе работы программы изменять их значение.
Начиная с Java 10 в язык было добавлено ключевое слово var, которое также позволяет определять переменную:
Слово var ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, var x = 10, значит, переменная будет представлять тип int.Но если переменная объявляется с помощью var, то мы обязательно должны инициализировать ее.
Константы. В отличие от переменных константам можно присвоить значение только один раз. Объявляется как переменная, только вначале идет ключевое слово final. Обычно имя в верхнем регистре. Константы позволяют задать такие переменные, которые не должны больше изменяться.
boolean: хранит значение true или false
byte: хранит целое число от -128 до 127 и занимает 1 байт
short: хранит целое число от -32768 до 32767 и занимает 2 байта
int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта
long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт
double: хранит число с плавающей точкой от ±4.9*10-324 до ±1.7976931348623157*10308 и занимает 8 байт В качестве разделителя целой и дробной части в дробных литералах используется точка.
float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта
char: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта, поэтому диапазон хранимых значений от 0 до 65535
Все целочисленные литералы, например, числа 10, 4, -5, воспринимаются как значения типа int, однако мы можем присваивать целочисленные литералы другим целочисленным типам: byte, long, short. В этом случае Java автоматически осуществляет соответствующие преобразования:
byte a = 1; short b = 2; long c = 2121;
Однако если мы захотим присвоить переменной типа long очень большое число, которое выходит за пределы допустимых значений для типа int, то мы столкнемся с ошибкой во время компиляции:
Как правило, значения для целочисленных переменных задаются в десятичной системе счисления, но можно применять и другие системы счисления. Для задания шестнадцатеричного значения после символов 0x указывается число в шестнадцатеричном формате. Таким же образом восьмеричное значение указывается после символа 0, а двоичное значение - после символов 0b. Также целые числа поддерживают разделение разрядов числа с помощью знака подчеркивания:
Чтобы указать, что данное значение должно рассматриваться как float, нам надо использовать суффикс f, иначе Java автоматически рассматривает этот литерал как значение типа double
float fl = 30.6f;
double db = 30.6;
И хотя в данном случае обе переменных имеют практически одно значения, но эти значения будут по-разному рассматриваться и будут занимать разное место в памяти.
	Символьные переменные
Значение переменной символьного типа - одиночный символ в одинарных кавычках: char ch='e';. Типа также можно присвоить целочисленное значение от 0 до 65535. Тогда переменная будет хранить символ, а целочисленное значение будет указывать на номер символа в таблице символов Unicode (UTF-16). Например: char ch=102; // символ 'f'
Или в шестнадцатеричной форме, которое следует после символов "\u". Например, char ch='\u0066'; опять же будет хранить символ 'f'.
Символьные не строковыме, 'a' не идентично "a". Строковые не примиитвные как  char, а объект String.
Ещё есть специальные наборы символов, которые называют управляющими последовательностями. Например, самая популярная последовательность - "\n". Она выполняет перенос на следующую строку.
Начиная с версии 15 Java поддерживает тестовые блоки (text blocks) - многострочный текст (абзац, стих), облеченный в тройные кавычки.
Для создания потока вывода в класс System определен объект out. В этом объекте определен метод println
System.out.println("Hello world!"); с переносом строки
System.out.print("Hello world!"); без переноса строки
System.out.print("Hello world! \n");
Но в Java есть также функция для форматированного вывода, унаследованная от языка С: System.out.printf()
System.out.printf("x=%d; y=%d \n", x, y);
Кроме спецификатора %d мы можем использовать еще ряд спецификаторов для других типов данных:
%x: для вывода шестнадцатеричных чисел
%f: для вывода чисел с плавающей точкой (%.2f, где .2 указывает, что после запятой будет два знака.)
%e: для вывода чисел в экспоненциальной форме, например, 1.3e+01
%c: для вывода одиночного символа
%s: для вывода строковых значений
 Scanner in = new Scanner(System.in); 
 Для получения ввода с консоли в классе System определен объект in. Однако непосредственно через объект System.in не очень удобно работать, поэтому, как правило, используют класс Scanner, который, в свою очередь использует System.in. Например, напишем маленькую программу, которая осуществляет 
 Класс Scanner имеет еще ряд методов, которые позволяют получить введенные пользователем значения:
next(): считывает введенную строку до первого пробела
nextLine(): считывает всю введенную строку
nextInt(): считывает введенное число int
nextDouble(): считывает введенное число double
nextBoolean(): считывает значение boolean
nextByte(): считывает введенное число byte
nextFloat(): считывает введенное число float
nextShort(): считывает введенное число short
		Арифметические операции
	Большинство операций в Java аналогичны тем, которые применяются в других си-подобных языках. Есть унарные операции (выполняются над одним операндом), бинарные - над двумя операндами, а также тернарные - выполняются над тремя операндами. + - * / % ++ (префиксный инкремент/декремент) ++a(--а), ++ (постфиксный инкремент/декремент) а++(а--);
	Приоритет арифметических операций
Одни операции имеют больший приоритет, чем другие, и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:
++ (постфиксный инкремент), -- (постфиксный декремент)
++ (префиксный инкремент), -- (префиксный декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)
Скобки позволяют переопределить порядок вычислений (сначала выполняется в скобках). Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. Левоассоциативные операторы и Правоассоциативные операторы.
Все арифметические операторы (кроме префиксного инкремента и декремента) являются левоассоциативными, то есть выполняются слева направо
Числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными. Например:
double d = 2.0 - 1.1;
System.out.println(d);
В данном случае переменная d будет равна не 0.9, как можно было бы изначально предположить, а 0.8999999999999999. Подобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система, однако для числа 0.1 не существует двоичного представления, также как и для других дробных значений. Поэтому в таких случаях обычно применяется класс BigDecimal, который позволяет обойти подобные ситуации.	
	Разобрать подробно побитовые операции https://metanit.com/java/tutorial/2.13.php
	Условные выражения
Условные выражения представляют собой некоторое условие и возвращают значение типа boolean, то есть значение true (если условие истинно), или значение false (если условие ложно). К условным выражениям относятся операции сравнения и логические операции.
	Операции сравнения 
	== != > < >= <=
	Логические операции
Также в Java есть логические операции, которые также представляют условие и возвращают true или false и обычно объединяют несколько операций сравнения. К логическим операциям относят следующие:
| c=a|b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
& c=a&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
! c=!b; (c равно true, если b равно false, иначе c будет равно false)
^ c=a^b; (c равно true, если либо a, либо b (но не одновременно) равны true, иначе c будет равно false)
|| c=a||b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
&& c=a&&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
Здесь у нас две пары операций | и || (а также & и &&) выполняют похожие действия, однако же они не равнозначны.
Выражение c=a|b; будет вычислять сначала оба значения - a и b и на их основе выводить результат.
В выражении же c=a||b; вначале будет вычисляться значение a, и если оно равно true, то вычисление значения b уже смысла не имеет, так как у нас в любом случае уже c будет равно true. Значение b будет вычисляться только в том случае, если a равно false
То же самое касается пары операций &/&&. В выражении c=a&b; будут вычисляться оба значения - a и b.
	Преобразования базовых типов данных
int a = 4;
byte b = a; // ! Ошибка
byte b = (byte)a;  // преобразование типов: от типа int к типу byte
System.out.println(b); // 4
Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) - они расширяют представление объекта в памяти. Например:
byte b = 7;
int d = b;  // преобразование от byte к int
В данном случае значение типа byte, которое занимает в памяти 1 байт, расширяется до типа int, которое занимает 4 байта.
Расширяющие автоматические преобразования представлены следующими цепочками:
byte -> short -> int -> long
int -> double
short -> float -> double
char -> int
Автоматические преобразования с потерей точности
следующие цепочки преобразований: int -> float, long -> float и long -> double. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.
Например:
int a = 2147483647;
float b = a;            // от типа int к типу float
System.out.println(b);  // 2.14748365E9
		Условные конструкции
	Одним из фундаментальных элементов многих языков программирования являются условные конструкции. Данные конструкции позволяют направить работу программы по одному из путей в зависимости от определенных условий.
В языке Java используются следующие условные конструкции: if..else и switch..case
Тернарная операция
Тернарную операция имеет следующий синтаксис: [первый операнд - условие] ? [второй операнд] : [третий операнд]. 
Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке Java есть следующие виды циклов:
for
while
do...while
Операторы continue и break
for (int i = 0; i < 10; i++){
    if (i == 5)
        break; (или continue) 
    System.out.println(i);
}
Оператор break позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу
используем оператор continue чтобы если число равно 5, цикл не завершался, а просто переходил к следующей итерации. В этом случае, когда выполнение цикла дойдет до числа 5, программа просто пропустит это число и перейдет к следующему.
	Массивы
int nums[] = new int[4];    // массив из 4 чисел
int[] nums2 = new int[5];   // массив из 5 чисел
// эти два способа равноценны
int[] nums = new int[] { 1, 2, 3, 5 };
int[] nums2 = { 1, 2, 3, 5 };
После создания массива мы можем обратиться к любому его элементу по индексу, который передается в квадратных скобках после названия переменной массива:
int[] nums = new int[4];
// устанавливаем значения элементов массива
nums[0] = 1;
nums[1] = 2;
nums[2] = 4;
nums[3] = 100;
// получаем значение третьего элемента массива
System.out.println(nums[2]);    // 4
Длина массива
Важнейшее свойство массива - свойство length, возвращающее длину массива, то есть количество его элементов:
int[] nums = {1, 2, 3, 4, 5};
int length = nums.length;   // 5
Нередко бывает неизвестным последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:1
int last = nums[nums.length-1];
	Двухмерный массив
	int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
Двухмерный массив представляет собой простую таблицу. Его также можно создать так: int[][] nums2 = new int[2][3];
Объявление трехмерного массива могло бы выглядеть так:
int[][][] nums3 = new int[2][3][4];
	Зубчатый массив
мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:
int[][] nums = new int[3][];
nums[0] = new int[2];
nums[1] = new int[3];
nums[2] = new int[5];
	foreach
Специальная версия цикла for предназначена для перебора элементов в наборах элементов, например, в массивах и коллекциях. Она аналогична действию цикла foreach , который имеется в других языках программирования. Формальное ее объявление:
for (тип_данных название_переменной : контейнер){
    // действия
}
int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i : array){
    System.out.println(i);
}
 Но эта версия не такая гибкая как for (int i = 0; i < array.length; i++){}
 	Перебор многомерных массивов в цикле
int[][] nums = new int[][] 
{ 
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
for (int i = 0; i < nums.length; i++){
    for(int j=0; j < nums[i].length; j++){
             
        System.out.printf("%d ", nums[i][j]);
    }
    System.out.println();
} Подобным образом можно перебрать и трехмерные массивы и наборы с большим количеством размерностей.
	методы
методы содержат собой набор операторов, которые выполняют определенные действия.
Общее определение методов выглядит следующим образом:
[модификаторы] тип_возвращаемого_значения название_метода ([параметры]){
    // тело метода
}
Модификаторы и параметры необязательны.
Вызов метода осуществляется в форме:
имя_метода(аргументы, т.е. значения для параметров метода);
	Параметры переменной длины
 static void sum(int ...nums){
         
        int result =0;
        for(int n: nums)
            result += n;
        System.out.println(result);
    }
 если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:
 static void sum(String message, int ...nums){...
 Методы могут возвращать некоторое значение. Для этого применяется оператор return, а в методе вместо void указывается какой тип будет возвращаться. Причём, если не void, то метод обязательно должен использовать оператор return, возвращая значения указанного типа.
static int sum(int a, int b, int c){
        return a + b + c;
    }}
Можно использовать для выхода из метода, если метод void, то return; без значения вызывает выход из метода.
	Перегрузка методов
Использование методов с одним и тем же именем, но с разными типами и/или количеством параметров. Можно возвращать разные типы.
	static int sum(int x, int y){
        return x + y;
    }
    static double sum(double x, double y){
        return x + y;
    }
Рекурсивные функции
рекурсивная функция может вызывать саму себя.
static int factorial(int x){
    if (x == 1){
        return 1;
    }
    return x * factorial(x - 1);
}
Фибоначи
static int fibonachi(int n){
 
    if (n == 0){
        return 0;
    }
    if (n == 1){
        return 1;
    }
    else{
        return fibonachi(n - 1) + fibonachi(n - 2);
    }
}
		//Разобрать подробнее Exceptions
	Классы и объекты
Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса.
Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта в классе применяются методы. 
Как правило, классы определяются в разных файлах. 
Класс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип.
 Person tom = new Person(); // создание объекта
Для создания объекта Person используется выражение new Person(). Оператор new выделяет память для объекта Person. И затем вызывается конструктор по умолчанию, который не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная tom получит ссылку на созданный объект.
Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число 0, а для типа string и классов - это значение null (то есть фактически отсутствие значения).
Ключевое слово this представляет ссылку на текущий экземпляр класса. Через это ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы. чтобы разграничить поля и параметры, применяется ключевое слово this:
this.name = name;
Так, в данном случае указываем, что значение параметра name присваивается полю name.

		//Разобрать подробнее	Кроме того, у нас три конструктора, которые выполняют идентичные действия: устанавливают поля name и age. Чтобы избежать повторов, с помощью this можно вызвать один из конструкторов класса и передать для его параметров необходимые значения:
			Person(String name)
			{
				this(name, 18);
			}

Инициализаторы
Кроме конструктора начальную инициализацию объекта вполне можно было проводить с помощью инициализатора объекта. Инициализатор выполняется до любого конструктора. То есть в инициализатор мы можем поместить код, общий для всех конструкторов:
class Person{
     
    String name;    // имя
    int age;        // возраст
     
    /*начало блока инициализатора*/
    {
        name = "Undefined";
        age = 18;
    }
    /*конец блока инициализатора*/

Возможна ситуация, когда мы используем два класса с одним и тем же названием из двух разных пакетов, например, класс Date имеется и в пакете java.util, и в пакете java.sql. И если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:
java.util.Date utilDate = new java.util.Date();
java.sql.Date sqlDate = new java.sql.Date();
Статический импорт
В java есть также особая форма импорта - статический импорт. Для этого вместе с директивой import используется модификатор static:
package study;
 
import static java.lang.System.*;
import static java.lang.Math.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        double result = sqrt(20);
        out.println(result);
    } 
}
Здесь происходит статический импорт классов System и Math. Эти классы имеют статические методы. Благодаря операции статического импорта мы можем использовать эти методы без названия класса. Например, писать не Math.sqrt(20), а sqrt(20), так как функция sqrt(), которая возвращает квадратный корень числа, является статической. (Позже мы рассмотрим статические члены класса).

То же самое в отношении класса System: в нем определен статический объект out, поэтому мы можем его использовать без указания класса.

		Модификаторы доступа и инкапсуляция
	Все члены класса в языке Java - поля и методы - имеют модификаторы доступа. Модификаторы доступа позволяют задать допустимую область видимости для членов класса, то есть контекст, в котором можно употреблять данную переменную или метод.
В Java используются следующие модификаторы доступа:
 - public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
 - private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
 - protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
 - Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.
	Pекомендуется как можно больше ограничивать доступ к данным, чтобы защитить их от нежелательного доступа извне (как для получения значения, так и для его изменения). Использование различных модификаторов гарантирует, что данные не будут искажены или изменены не надлежащим образом. Подобное сокрытие данных внутри некоторой области видимости называется инкапсуляцией.
И затем вместо непосредственной работы с полями name и age в классе Person мы будем работать с методами, которые устанавливают и возвращают значения этих полей. Методы setName, setAge и наподобие еще называют мьютейтерами (mutator), так как они изменяют значения поля. А методы getName, getAge и наподобие называют аксессерами (accessor), так как с их помощью мы получаем значение поля. Причем в эти методы мы можем вложить дополнительную логику.
	Статические поля
При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. А статические поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.
	Статические константы
Также статическими бывают константы, которые являются общими для всего класса. System.out.println("hello"); Здесь out как раз представляет статическую константу класса System. Поэтому обращение к ней идет без создания объекта класса System.
	Статические инициализаторы
Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких действий, которые выполняются при создании самого первого объекта. Стоит учитывать, что вызов статического инициализатора производится после загрузки класса и фактически до создания самого первого объекта класса.
	Статические методы
Статические методы также относятся ко всему классу в целом. статическая переменная недоступна извне, она приватная. А ее значение выводится с помощью статического метода displayCounter. Для обращения к статическому методу используется имя класса: Person.displayCounter().
При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные.
Вообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса.
	Объекты как параметры методов
Объекты классов, как и данные примитивных типов, могут передаваться в методы. Однако в данном случае есть одна особенность - при передаче объектов в качестве значения передается копия ссылки на область в памяти, где расположен этот объект. Поэтому следует помнить, что надо создавать new объекты, иначе просто перезаписываешь содержимоет объекта.
	Внутренние и вложенные классы
Классы могут быть вложенными (nested), то есть могут быть определены внутри других классов. Частным случаем вложенных классов являются внутренние классы (inner class).	
Внутренний класс ведет себя как обычный класс за тем исключением, что его объекты могут быть созданы только внутри внешнего класса.
Внутренний класс имеет доступ ко всем полям внешнего класса, в том числе закрытым с помощью модификатора private. Аналогично внешний класс имеет доступ ко всем членам внутреннего класса, в том числе к полям и методам с модификатором private.
Ссылку на объект внешнего класса из внутреннего класса можно получить с помощью выражения Внешний_класс.this, например, Person.this.
Объекты внутренних классов могут быть созданы только в том классе, в котором внутренние классы опеределены. В других внешних классах объекты внутреннего класса создать нельзя.
Еще одной особенностью внутренних классов является то, что их можно объявить внутри любого контекста, в том числе внутри метода и даже в цикле
	Статические вложенные классы
Кроме внутренних классов также могут быть статические вложенные классы. Статические вложенные классы позволяют скрыть некоторую комплексную информацию внутри внешнего класса
Здесь определен вложенный класс для хранения данных о вычислении факториала. Основные действия выполняет метод getFactorial, который возвращает объект вложенного класса  https://metanit.com/java/tutorial/3.12.php
	Наследование extends
Позволяет расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого. Наследник является производным (наследником, подклассом) от класса Person, который, в свою очередь, называется базовым классом, родителем или суперклассом:
 базовый класс/родитель/суперкласс -> производный класс/наследник/подкласс
 Для класса Employee базовым является Person, и поэтому класс Employee наследует все те же поля и методы, которые есть в классе Person.
class Employee extends Person{
    public Employee(String name){
        super(name);    // если базовый класс определяет конструктор
                        //  то производный класс должен его вызвать
    }
}  



















Хитрости для собеса
Integer num1 = 100;
Integer num2 = 100;
Программа напечатает «num1 == num2». Если мы сравниваем две ссылки на объекты с помощью ==, значение всегда будет «false». Но в этом примере переменные num1 и num2 автоупаковываются (autoboxing) из-за Integer-кэширования. Вот почему num1 == num2 возвращает значение «true». Не забудьте, что Integer-кэширование актуально только для значений от -128 до 127.














